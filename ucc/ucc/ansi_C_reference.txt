
purpose: 1.1
scope: 1.2
references: 1.3
organization of the document: 1.4
base documents: 1.5
definitions of terms: 1.6
compliance: 1.7
translation environment: 2.
execution environment: 2.
separate compilation: 2.1.1.1
separate translation: 2.1.1.1
source file: 2.1.1.1
translation unit: 2.1.1.1
program execution: 2.1.2.3
side effects: 2.1.2.3
sequence point: 2.1.2.3
character set: 2.2.1
signals: 2.2.3
interrupts: 2.2.3
syntax notation: 3.
lexical elements: 3.1
comment: 3.1
white space: 3.1
list of keywords: 3.1.1
reserved words: 3.1.1
underscore character: 3.1.2
enumeration constant: 3.1.2
length of names: 3.1.2
internal name, length of: 3.1.2
external name, length of: 3.1.2
function name, length of: 3.1.2
scopes: 3.1.2.1
prototype, function: 3.1.2.1
function scope: 3.1.2.1
file scope: 3.1.2.1
block scope: 3.1.2.1
block structure: 3.1.2.1
function prototype scope: 3.1.2.1
linkage: 3.1.2.2
external linkage: 3.1.2.2
internal linkage: 3.1.2.2
no linkage: 3.1.2.2
name spaces: 3.1.2.3
named label: 3.1.2.3
structure tag: 3.1.2.3
union tag: 3.1.2.3
enumeration tag: 3.1.2.3
structure member name: 3.1.2.3
union member name: 3.1.2.3
storage duration: 3.1.2.4
static storage duration: 3.1.2.4
automatic storage duration: 3.1.2.4
types: 3.1.2.5
object types: 3.1.2.5
function types: 3.1.2.5
incomplete types: 3.1.2.5
char type: 3.1.2.5
signed character: 3.1.2.5
signed char type: 3.1.2.5
short type: 3.1.2.5
long type: 3.1.2.5
unsigned type: 3.1.2.5
float type: 3.1.2.5
double type: 3.1.2.5
long double type: 3.1.2.5
basic types: 3.1.2.5
character types: 3.1.2.5
enumerated type: 3.1.2.5
void type: 3.1.2.5
derived types: 3.1.2.5
integral types: 3.1.2.5
arithmetic types: 3.1.2.5
scalar types: 3.1.2.5
aggregate types: 3.1.2.5
constants: 3.1.3
floating constant: 3.1.3.1
double constant: 3.1.3.1
integer constant: 3.1.3.2
decimal constant: 3.1.3.2
octal constant: 3.1.3.2
hexadecimal constant: 3.1.3.2
unsigned constant: 3.1.3.2
long constant: 3.1.3.2
enumeration constant: 3.1.3.3
character constant: 3.1.3.4
backslash character: 3.1.3.4 
escape character: 3.1.3.4
escape sequence: 3.1.3.4
string literal: 3.1.4
character string: 3.1.4
operator: 3.1.5
evaluation: 3.1.5
operand: 3.1.5
punctuator: 3.1.6
character-integer conversion: 3.2.1.1
integer-character conversion: 3.2.1.1
integral promotions: 3.2.1.1
integer-long conversion: 3.2.1.1
signed character: 3.2.1.1
unsigned-integer conversion: 3.2.1.2
integer-unsigned conversion: 3.2.1.2
long-unsigned conversion: 3.2.1.2
long-integer conversion: 3.2.1.2
floating-integer conversion: 3.2.1.3
integer-floating conversion: 3.2.1.3
float-double conversion: 3.2.1.4
double-float conversion: 3.2.1.4
arithmetic conversions: 3.2.1.5
type conversion rules: 3.2.1.5
lvalue: 3.2.2.1
function designator: 3.2.2.1
conversion of array: 3.2.2.1
conversion of function name: 3.2.2.1
void type: 3.2.2.2
pointer-pointer conversion: 3.2.2.3
integer-pointer conversion: 3.2.2.3
null pointer: 3.2.2.3
expression: 3.3
precedence of operators: 3.3
associativity of operators: 3.3
order of evaluation of expressions: 3.3
order of evaluation: 3.3
bitwise operators: 3.3
exceptions: 3.3
primary expression: 3.3.1
type of string: 3.3.1
parenthesized expression: 3.3.1
subscript operator: 3.3.2
function call: 3.3.2
structure member operator: 3.3.2
structure pointer operator: 3.3.2
++ increment operator: 3.3.2
-- decrement operator: 3.3.2
array, explanation of subscripting: 3.3.2.1
subscripting, explanation of: 3.3.2.1
multi-dimensional array: 3.3.2.1
storage order of array: 3.3.2.1
function call: 3.3.2.2
implicit declaration of function: 3.3.2.2
function argument: 3.3.2.2
call by value: 3.3.2.2
recursion: 3.3.2.2
structure reference: 3.3.2.3
union reference: 3.3.2.3
common initial sequence: 3.3.2.3
postfix ++ and --: 3.3.2.4
-- decrement operator: 3.3.2.4
unary expression: 3.3.3
++ increment operator: 3.3.3
-- decrement operator: 3.3.3
sizeof operator: 3.3.3
& address operator: 3.3.3
* indirection operator: 3.3.3
+ unary plus operator: 3.3.3
- unary minus operator: 3.3.3
~ bitwise complement operator: 3.3.3
! logical negation operator: 3.3.3
++ increment operator: 3.3.3.1
prefix ++ and --: 3.3.3.1
-- decrement operator: 3.3.3.1
+ unary plus operator: 3.3.3.3
- unary minus operator: 3.3.3.3
~ bitwise complement operator: 3.3.3.3
! logical negation operator: 3.3.3.3
byte: 3.3.3.4
storage allocator: 3.3.3.4
cast expression: 3.3.4
cast operator: 3.3.4
explicit conversion operator: 3.3.4
cast operator: 3.3.4
pointer conversion: 3.3.4
explicit conversion operator: 3.3.4
pointer-integer conversion: 3.3.4
integer-pointer conversion: 3.3.4
alignment restriction: 3.3.4
arithmetic operators: 3.3.5
multiplicative operators: 3.3.5
* multiplication operator: 3.3.5
/ division operator: 3.3.5
% modulus operator: 3.3.5
additive operators: 3.3.6
+ addition operator: 3.3.6
- subtraction operator: 3.3.6
pointer arithmetic: 3.3.6
pointer arithmetic: 3.3.6
shift operators: 3.3.7
<< left shift operator: 3.3.7
>> right shift operator: 3.3.7
relational operators: 3.3.8
< less than operator: 3.3.8
> greater than operator: 3.3.8
<= less than or equal to operator: 3.3.8
>= greater than or equal to operator: 3.3.8
pointer comparison: 3.3.8
equality operators: 3.3.9
== equality operator: 3.3.9
!= inequality operator: 3.3.9
& bitwise AND operator: 3.3.10
^ bitwise exclusive OR operator: 3.3.11
| bitwise inclusive OR operator: 3.3.12
&& logical AND operator: 3.3.13
|| logical OR operator: 3.3.14
?: conditional expression: 3.3.15
assignment operators: 3.3.16
assignment expression: 3.3.16
simple assignment: 3.3.16.1
conversion by assignment: 3.3.16.1
compound assignment: 3.3.16.2
comma operator: 3.3.17
constant expression: 3.4
permitted form of initializer: 3.4
declarations: 3.5
storage-class specifier: 3.5.1
storage-class declaration: 3.5.1
typedef declaration: 3.5.1
extern storage class: 3.5.1
static storage class: 3.5.1
auto storage class: 3.5.1
register storage class: 3.5.1
type specifier: 3.5.2
void type: 3.5.2
char type: 3.5.2
short type: 3.5.2
int type: 3.5.2
long type: 3.5.2
float type: 3.5.2
double type: 3.5.2
signed type: 3.5.2
unsigned type: 3.5.2
structure declaration: 3.5.2.1
union declaration: 3.5.2.1
bit-field declaration: 3.5.2.1
bit-field: 3.5.2.1
member alignment: 3.5.2.1
enumeration: 3.5.2.2
enum-specifier: 3.5.2.2
enumerator: 3.5.2.2
structure tag: 3.5.2.3
union tag: 3.5.2.3
structure content: 3.5.2.3
union content: 3.5.2.3
enumeration content: 3.5.2.3
self-referential structure: 3.5.2.3
type qualifier: 3.5.3
const type qualifier: 3.5.3
volatile type qualifier: 3.5.3
declarator: 3.5.4
type declaration: 3.5.4
declaration of pointer: 3.5.4.1
array declaration: 3.5.4.2
declaration of function: 3.5.4.3
type names: 3.5.5
abstract declarator: 3.5.5
typedef declaration: 3.5.6
initialization: 3.5.7
initialization of statics: 3.5.7
implicit initialization: 3.5.7
default initialization: 3.5.7
initialization of automatics: 3.5.7
aggregate initialization: 3.5.7
array initialization: 3.5.7
structure initialization: 3.5.7
character array initialization: 3.5.7
wchar_t array initialization: 3.5.7
statements: 3.6
sequencing of statements: 3.6
full expression: 3.6
labeled statement: 3.6.1
named label: 3.6.1
case label: 3.6.1
default label: 3.6.1
compound statement: 3.6.2
block: 3.6.2
block structure: 3.6.2
initialization in blocks: 3.6.2
expression statement: 3.6.3
null statement: 3.6.3
empty statement: 3.6.3
if-else statement: 3.6.4.1
switch statement: 3.6.4.2
switch body: 3.6.4.2
loop body: 3.6.5
while statement: 3.6.5.1
do statement: 3.6.5.2
for statement: 3.6.5.3
goto statement: 3.6.6.1
continue statement: 3.6.6.2
break statement: 3.6.6.3
return statement: 3.6.6.4
type conversion by return: 3.6.6.4
conversion by return: 3.6.6.4
external definition: 3.7
function definition: 3.7.1
parameter: 3.7.1
array argument: 3.7.1
function name argument: 3.7.1
pointer to function: 3.7.1
object definitions: 3.7.2
scope of externals: 3.7.2
tentative definition: 3.7.2
preprocessing directives: 3.8
macro preprocessor: 3.8
preprocessing directive lines: 3.8
conditional inclusion: 3.8.1
#if: 3.8.1
#elif 3.8.1
#ifdef: 3.8.1
#ifndef: 3.8.1
#else: 3.8.1
#endif: 3.8.1
#include: 3.8.2
source file inclusion: 3.8.2
macro replacement: 3.8.3
object-like macro: 3.8.3
function-like macro: 3.8.3
macro name: 3.8.3
#define: 3.8.3
macro parameters: 3.8.3
macro invocation: 3.8.3
argument substitution: 3.8.3.1
# operator: 3.8.3.2
## operator: 3.8.3.3
rescanning and replacement: 3.8.3.4
macro definition scope: 3.8.3.5
#undef: 3.8.3.5
#line: 3.8.4
error directive: 3.8.5
pragma directive: 3.8.6
null directive: 3.8.7
introduction: 4.1
string definition: 4.1.1
letter definition: 4.1.1
decimal-point definition: 4.1.1
reserved identifier: 4.1.2
printing character: 4.3
control character: 4.3
variable arguments: 4.8
unbuffered stream: 4.9.3
fully buffered stream: 4.9.3
line buffered stream: 4.9.3
appendices: A.
language syntax summary: A.1
sequence points: A.2
library summary: A.3
implementation limits: A.4
warnings: A.5
portability: A.6
order of evaluation: A.6.1
machine dependency: A.6.3
restrictions on registers: A.6.3.7
function pointer casts: A.6.5.7
bit-field types: A.6.5.8
fortran keyword: A.6.5.9
asm keyword: A.6.5.10
multiple external definitions: A.6.5.11
empty macro arguments: A.6.5.12
predefined macro names: A.6.5.13
signal handler arguments: A.6.5.14
stream types: A.6.5.15
file-opening modes: A.6.5.15
file position indicator: A.6.5.16
foreword: A.7


1. INTRODUCTION

1.1 PURPOSE

   This Standard specifies the form and establishes the interpretation
   of programs written in the C programming language./1/

1.2 SCOPE

   This Standard specifies: 

 * the representation of C programs; 

 * the syntax and constraints of the C language; 

 * the semantic rules for interpreting C programs; 

 * the representation of input data to be processed by C programs; 

 * the representation of output data produced by C programs; 

 * the restrictions and limits imposed by a conforming implementation of C.  


   This Standard does not specify: 

 * the mechanism by which C programs are transformed for use by a
   data-processing system;

 * the mechanism by which C programs are invoked for use by a
   data-processing system;

 * the mechanism by which input data are transformed for use by a C program; 

 * the mechanism by which output data are transformed after being
   produced by a C program;

 * the size or complexity of a program and its data that will exceed
   the capacity of any specific data-processing system or the capacity of
   a particular processor;

 * all minimal requirements of a data-processing system that is
   capable of supporting a conforming implementation.


1.3 REFERENCES

 1. ``The C Reference Manual'' by Dennis M. Ritchie, a version of
    which was published in The C Programming Language by Brian
    W. Kernighan and Dennis M. Ritchie, Prentice-Hall, Inc., (1978).
    Copyright owned by AT&T.

 2. 1984 /usr/group Standard by the /usr/group Standards Committee,
    Santa Clara, California, USA (November, 1984).

 3. American National Dictionary for Information Processing Systems,
    Information Processing Systems Technical Report ANSI X3/TR-1-82 (1982).

 4. ISO 646-1983 Invariant Code Set.  

 5. IEEE Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985).  

 6. ISO 4217 Codes for the Representation of Currency and Funds.  


1.4 ORGANIZATION OF THE DOCUMENT

   This document is divided into four major sections: 

 1. this introduction; 

 2. the characteristics of environments that translate and execute C programs; 

 3. the language syntax, constraints, and semantics; 

 4. the library facilities.  

Examples are provided to illustrate possible forms of the
constructions described.  Footnotes are provided to emphasize
consequences of the rules described in the section or elsewhere in the
Standard.  References are used to refer to other related sections.  A
set of appendices summarizes information contained in the Standard.
The abstract, the foreword, the examples, the footnotes, the
references, and the appendices are not part of the Standard.

1.5 BASE DOCUMENTS

The language section ($3) is derived from ``The C Reference
Manual'' by Dennis M. Ritchie, a version of which was published as
Appendix A of The C Programming Language by Brian W. Kernighan and
Dennis M. Ritchie, Prentice-Hall, Inc., 1978; copyright owned by AT&T.

The library section ($4) is based on the 1984 /usr/group Standard by
the /usr/group Standards Committee, Santa Clara, California, USA
(November 14, 1984).

1.6 DEFINITIONS OF TERMS

   In this Standard, ``shall'' is to be interpreted as a requirement
on an implementation or on a program; conversely, ``shall not'' is to
be interpreted as a prohibition.

The following terms are used in this document: 

 * Implementation --- a particular set of software, running in a
   particular translation environment under particular control options,
   that performs translation of programs for, and supports execution of
   functions in, a particular execution environment.

 * Bit --- the unit of data storage in the execution environment large
   enough to hold an object that may have one of two values.  It need not
   be possible to express the address of each individual bit of an
   object.

 * Byte --- the unit of data storage in the execution environment
   large enough to hold any member of the basic character set of the
   execution environment.  It shall be possible to express the address of
   each individual byte of an object uniquely.  A byte is composed of a
   contiguous sequence of bits, the number of which is
   implementation-defined.  The least significant bit is called the
   low-order bit; the most significant bit is called the high-order bit.

 * Object --- a region of data storage in the execution environment,
   the contents of which can represent values.  Except for bit-fields,
   objects are composed of contiguous sequences of one or more bytes, the
   number, order, and encoding of which are either explicitly specified
   or implementation-defined.

 * Character --- a single byte representing a member of the basic
   character set of either the source or the execution environment.

 * Multibyte character --- a sequence of one or more bytes
   representing a member of the extended character set of either the
   source or the execution environment.  The extended character set is a
   superset of the basic character set.

 * Alignment --- a requirement that objects of a particular type be
   located on storage boundaries with addresses that are particular
   multiples of a byte address.

 * Argument --- an expression in the comma-separated list bounded by
   the parentheses in a function call expression, or a sequence of
   preprocessing tokens in the comma-separated list bounded by the
   parentheses in a function-like macro invocation.  Also known as
   ``actual argument'' or ``actual parameter.''

 * Parameter --- an object declared as part of a function declaration
   or definition that acquires a value on entry to the function, or an
   identifier from the comma-separated list bounded by the parentheses
   immediately following the macro name in a function-like macro
   definition.  Also known as ``formal argument'' or ``formal
   parameter.''

 * Unspecified behavior --- behavior, for a correct program construct
   and correct data, for which the Standard imposes no requirements.

 * Undefined behavior --- behavior, upon use of a nonportable or
   erroneous program construct, of erroneous data, or of
   indeterminately-valued objects, for which the Standard imposes no
   requirements.  Permissible undefined behavior ranges from ignoring the
   situation completely with unpredictable results, to behaving during
   translation or program execution in a documented manner characteristic
   of the environment (with or without the issuance of a diagnostic
   message), to terminating a translation or execution (with the issuance
   of a diagnostic message).

   If a ``shall'' or ``shall not'' requirement that appears outside of
   a constraint is violated, the behavior is undefined.  Undefined 
   behavior is otherwise indicated in this Standard by the words
   ``undefined behavior'' or by the omission of any explicit definition
   of behavior.  There is no difference in emphasis among these three;
   they all describe ``behavior that is undefined.''

 * Implementation-defined behavior --- behavior, for a correct program
   construct and correct data, that depends on the characteristics of the
   implementation and that each implementation shall document.

 * Locale-specific behavior --- behavior that depends on local
   conventions of nationality, culture, and language that each
   implementation shall document.

 * Diagnostic message --- a message belonging to an
   implementation-defined subset of the implementation's message output.

 * Constraints --- syntactic and semantic restrictions by which the
   exposition of language elements is to be interpreted.

 * Implementation limits --- restrictions imposed upon programs by the
   implementation.

 * Forward references --- references to later sections of the Standard
   that contain additional information relevant to this section.

   Other terms are defined at their first appearance, indicated by italic
   type.  Terms explicitly defined in this Standard are not to be
   presumed to refer implicitly to similar terms defined elsewhere.

   Terms not defined in this Standard are to be interpreted according to
   the American National Dictionary for Information Processing Systems,
   Information Processing Systems Technical Report ANSI X3/TR-1-82 (1982).

Forward references: localization ($4.4).  

"Examples"

   An example of unspecified behavior is the order in which the
   arguments to a function are evaluated.

   An example of undefined behavior is the behavior on integer overflow.

   An example of implementation-defined behavior is the propagation of
   the high-order bit when a signed integer is shifted right.

   An example of locale-specific behavior is whether the islower
   function returns true for characters other than the 26 lower-case
   English letters.

Forward references: bitwise shift operators ($3.3.7), expressions
($3.3), function calls ($3.3.2.2), the islower function ($4.3.1.6).


1.7 COMPLIANCE

   A strictly conforming program shall use only those features of the
language and library specified in this Standard.  It shall not produce
output dependent on any unspecified, undefined, or
implementation-defined behavior, and shall not exceed any minimum
implementation limit.

   The two forms of conforming implementation are hosted and
freestanding.  A conforming hosted implementation shall accept any
strictly conforming program.  A conforming freestanding implementation
shall accept any strictly conforming program in which the use of the
features specified in the library section ($4) is confined to the
contents of the standard headers <float.h> , <limits.h> , <stdarg.h> ,
and <stddef.h> .  A conforming implementation may have extensions
(including additional library functions), provided they do not alter
the behavior of any strictly conforming program.

   A conforming program is one that is acceptable to a conforming
implementation./2/

   An implementation shall be accompanied by a document that defines
all implementation-defined characteristics and all extensions.

Forward references: limits <float.h> and <limits.h> ($4.1.4), variable
arguments <stdarg.h> ($4.8), common definitions <stddef.h> ($4.1.5).


1.8 FUTURE DIRECTIONS

   With the introduction of new devices and extended character sets,
new features may be added to the Standard.  Subsections in the
language and library sections warn implementors and programmers of
usages which, though valid in themselves, may conflict with future
additions.

   Certain features are obsolescent , which means that they may be
considered for withdrawal in future revisions of the Standard.  They
are retained in the Standard because of their widespread use, but
their use in new implementations (for implementation features) or new
programs (for language or library features) is discouraged.

Forward references: future language directions ($3.9.9), future
library directions ($4.13).

1.9 ABOUT THIS DRAFT

   Symbols in the right margin mark substantive differences between
this draft and its predecessor (ANSI X3J11/88-001, January 11, 1988).
A plus sign indicates an addition, a minus sign a deletion, and a
vertical bar a replacement.

   This section and the difference marks themselves will not appear in
the published document.


2. ENVIRONMENT

   An implementation translates C source files and executes C programs
in two data-processing-system environments, which will be called the
translation environment and the execution environment in this
Standard.  Their characteristics define and constrain the results of
executing conforming C programs constructed according to the syntactic
and semantic rules for conforming implementations.

Forward references: In the environment section ($2), only a few of
many possible forward references have been noted.


2.1 CONCEPTUAL MODELS

2.1.1 Translation environment

2.1.1.1 Program structure

   A C program need not all be translated at the same time.  The text
of the program is kept in units called source files in this Standard.
A source file together with all the headers and source files included
via the preprocessing directive #include , less any source lines
skipped by any of the conditional inclusion preprocessing directives,
is called a translation unit. Previously translated translation units
may be preserved individually or in libraries.  The separate
translation units of a program communicate by (for example) calls to
functions whose identifiers have external linkage, by manipulation of
objects whose identifiers have external linkage, and by manipulation
of data files.  Translation units may be separately translated and
then later linked to produce an executable program.

Forward references: conditional inclusion ($3.8.1), linkages of
identifiers ($3.1.2.2), source file inclusion ($3.8.2).

2.1.1.2 Translation phases

   The precedence among the syntax rules of translation is specified
by the following phases./3/

 1. Physical source file characters are mapped to the source character
    set (introducing new-line characters for end-of-line indicators) if
    necessary.  Trigraph sequences are replaced by corresponding
    single-character internal representations.

 2. Each instance of a new-line character and an immediately preceding
    backslash character is deleted, splicing physical source lines to form
    logical source lines.  A source file that is not empty shall end in a
    new-line character, which shall not be immediately preceded by a
    backslash character.

 3. The source file is decomposed into preprocessing tokens/4/ and
    sequences of white-space characters (including comments).  A source
    file shall not end in a partial preprocessing token or comment.  Each
    comment is replaced by one space character.  New-line characters are
    retained.  Whether each nonempty sequence of other white-space
    characters is retained or replaced by one space character is
    implementation-defined.

 4. Preprocessing directives are executed and macro invocations are
    expanded.  A #include preprocessing directive causes the named header
    or source file to be processed from phase 1 through phase 4,
    recursively.

 5. Each escape sequence in character constants and string literals is
    converted to a member of the execution character set.

 6. Adjacent character string literal tokens are concatenated and
    adjacent wide string literal tokens are concatenated.

 7. White-space characters separating tokens are no longer
    significant.  Preprocessing tokens are converted into tokens.  The
    resulting tokens are syntactically and semantically analyzed and
    translated.

 8. All external object and function references are resolved.  Library
    components are linked to satisfy external references to functions and
    objects not defined in the current translation.  All such translator
    output is collected into a program image which contains information
    needed for execution in its execution environment.

Forward references: lexical elements ($3.1), preprocessing directives
($3.8), trigraph sequences ($2.2.1.1).

2.1.1.3 Diagnostics

   A conforming implementation shall produce at least one diagnostic
message (identified in an implementation-defined manner) for every
translation unit that contains a violation of any syntax rule or
constraint.  Diagnostic messages need not be produced in other
circumstances.

2.1.2 Execution environments

   Two execution environments are defined: freestanding and hosted.
In both cases, program startup occurs when a designated C function
is called by the execution environment.  All objects in static storage
shall be initialized (set to their initial values) before program
startup.  The manner and timing of such initialization are otherwise
unspecified.  Program termination returns control to the execution
environment.

Forward references: initialization ($3.5.7).  

2.1.2.1 Freestanding environment

   In a freestanding environment (in which C program execution may
take place without any benefit of an operating system), the name and
type of the function called at program startup are
implementation-defined.  There are otherwise no reserved external
identifiers.  Any library facilities available to a freestanding
program are implementation-defined.

   The effect of program termination in a freestanding environment is
implementation-defined.

2.1.2.2 Hosted environment

   A hosted environment need not be provided, but shall conform to the
following specifications if present.

"Program startup"

   The function called at program startup is named main .  The
implementation declares no prototype for this function.  It can be
defined with no parameters:

         int main(void) { /*...*/ }

or with two parameters (referred to here as argc and argv , though any
names may be used, as they are local to the function in which they are
declared):

         int main(int argc, char *argv[]) { /*...*/ }


   If they are defined, the parameters to the main function shall obey
the following constraints:

 * The value of argc shall be nonnegative.  

 * argv[argc] shall be a null pointer.  

 * If the value of argc is greater than zero, the array members
   argv[0] through argv[argc-1] inclusive shall contain pointers to
   strings, which are given implementation-defined values by the host
   environment prior to program startup.  The intent is to supply to the
   program information determined prior to program startup from elsewhere
   in the hosted environment.  If the host environment is not capable of
   supplying strings with letters in both upper-case and lower-case, the
   implementation shall ensure that the strings are received in
   lower-case.

 * If the value of argc is greater than zero, the string pointed to by
   argv[0] represents the program name ;argv[0][0] shall be the null
   character if the program name is not available from the host
   environment.  If the value of argc is greater than one, the strings
   pointed to by argv[1] through argv[argc-1] represent the program
   parameters .

 * The parameters argc and argv and the strings pointed to by the argv
   array shall be modifiable by the program, and retain their last-stored
   values between program startup and program termination.

"Program execution"

   In a hosted environment, a program may use all the functions,
macros, type definitions, and objects described in the library section ($4).

"Program termination"

   A return from the initial call to the main function is equivalent
to calling the exit function with the value returned by the main
function as its argument.  If the main function executes a return that
specifies no value, the termination status returned to the host
environment is undefined.

Forward references: definition of terms ($4.1.1), the exit function
($4.10.4.3).


2.1.2.3 Program execution

   The semantic descriptions in this Standard describe the behavior of
an abstract machine in which issues of optimization are irrelevant.

   Accessing a volatile object, modifying an object, modifying a file,
or calling a function that does any of those operations are all side
effects ,which are changes in the state of the execution environment.
Evaluation of an expression may produce side effects.  At certain
specified points in the execution sequence called sequence points, all
side effects of previous evaluations shall be complete and no side
effects of subsequent evaluations shall have taken place.

   In the abstract machine, all expressions are evaluated as specified
by the semantics.  An actual implementation need not evaluate part of
an expression if it can deduce that its value is not used and that no
needed side effects are produced (including any caused by calling a
function or accessing a volatile object).

   When the processing of the abstract machine is interrupted by
receipt of a signal, only the values of objects as of the previous
sequence point may be relied on.  Objects that may be modified between
the previous sequence point and the next sequence point need not have
received their correct values yet.

   An instance of each object with automatic storage duration is
associated with each entry into a block.  Such an object exists and
retains its last-stored value during the execution of the block and
while the block is suspended (by a call of a function or receipt of a
signal).

   The least requirements on a conforming implementation are: 

 * At sequence points, volatile objects are stable in the sense that
   previous evaluations are complete and subsequent evaluations have not
   yet occurred.

 * At program termination, all data written into files shall be
   identical to the result that execution of the program according to the
   abstract semantics would have produced.

 * The input and output dynamics of interactive devices shall take
   place as specified in $4.9.3.  The intent of these requirements is
   that unbuffered or line-buffered output appear as soon as possible, to
   ensure that prompting messages actually appear prior to a program
   waiting for input.

   What constitutes an interactive device is implementation-defined.

   More stringent correspondences between abstract and actual
   semantics may be defined by each implementation.

"Examples"

   An implementation might define a one-to-one correspondence between
abstract and actual semantics: at every sequence point, the values of
the actual objects would agree with those specified by the abstract
semantics.  The keyword volatile would then be redundant.

   Alternatively, an implementation might perform various
optimizations within each translation unit, such that the actual
semantics would agree with the abstract semantics only when making
function calls across translation unit boundaries.  In such an
implementation, at the time of each function entry and function return
where the calling function and the called function are in different
translation units, the values of all externally linked objects and of
all objects accessible via pointers therein would agree with the
abstract semantics.  Furthermore, at the time of each such function
entry the values of the parameters of the called function and of all
objects accessible via pointers therein would agree with the abstract
semantics.  In this type of implementation, objects referred to by
interrupt service routines activated by the signal function would
require explicit specification of volatile storage, as well as other
implementation-defined restrictions.

   In executing the fragment 

         char c1, c2;
         /*...*/
         c1 = c1 + c2;

the ``integral promotions'' require that the abstract machine promote
the value of each variable to int size and then add the two int s and
truncate the sum.  Provided the addition of two char s can be done
without creating an overflow exception, the actual execution need only
produce the same result, possibly omitting the promotions.

   Similarly, in the fragment 

         float f1, f2;
         double d;
         /*...*/
         f1 = f2 * d;

the multiplication may be executed using single-precision arithmetic
if the implementation can ascertain that the result would be the same
as if it were executed using double-precision arithmetic (for example,
if d were replaced by the constant 2.0, which has type double ).
Alternatively, an operation involving only int s or float s may be
executed using double-precision operations if neither range nor
precision is lost thereby.

Forward references: compound statement, or block ($3.6.2), files
($4.9.3), sequence points ($3.3, $3.6), the signal function ($4.7),
type qualifiers ($3.5.3).


2.2 ENVIRONMENTAL CONSIDERATIONS

2.2.1 Character sets

   Two sets of characters and their associated collating sequences
shall be defined: the set in which source files are written, and the
set interpreted in the execution environment.  The values of the
members of the execution character set are implementation-defined; any
additional members beyond those required by this section are
locale-specific.

   In a character constant or string literal, members of the execution
character set shall be represented by corresponding members of the
source character set or by escape sequences consisting of the
backslash \ followed by one or more characters.  A byte with all bits
set to 0, called the null character, shall exist in the basic
execution character set; it is used to terminate a character string
literal.

   Both the basic source and basic execution character sets shall have
at least the following members: the 26 upper-case letters of the
English alphabet

         A  B  C  D  E  F  G  H  I  J  K  L  M
         N  O  P  Q  R  S  T  U  V  W  X  Y  Z

the 26 lower-case letters of the English alphabet 

         a  b  c  d  e  f  g  h  i  j  k  l  m
         n  o  p  q  r  s  t  u  v  w  x  y  z

the 10 decimal digits 

         0  1  2  3  4  5  6  7  8  9

the following 29 graphic characters 

         !  "  #  %  &  '  (  )  *  +  ,  -  .  /  :
         ;  <  =  >  ?  [  \  ]  ^  _  {  |  }  ~

the space character, and control characters representing horizontal
tab, vertical tab, and form feed.  In both the source and execution
basic character sets, the value of each character after 0 in the above
list of decimal digits shall be one greater than the value of the
previous.  In source files, there shall be some way of indicating the
end of each line of text; this Standard treats such an end-of-line
indicator as if it were a single new-line character.  In the execution
character set, there shall be control characters representing alert,
backspace, carriage return, and new line.  If any other characters are
encountered in a source file (except in a preprocessing token that is
never converted to a token, a character constant, a string literal, or
a comment), the behavior is undefined.

Forward references: character constants ($3.1.3.4), preprocessing
directives ($3.8), string literals ($3.1.4), comments ($3.1.9).


2.2.1.1 Trigraph sequences

   All occurrences in a source file of the following sequences of
three characters (called trigraph sequences /5/)are replaced with the
corresponding single character.

         ??=      #
         ??(      [
         ??/      \
         ??)      ]
         ??'      ^
         ??<      {
         ??!      |
         ??>      }
         ??-      ~

No other trigraph sequences exist.  Each ? that does not begin one of
the trigraphs listed above is not changed.

Example

   The following source line 

         printf("Eh???/n");

becomes (after replacement of the trigraph sequence ??/ ) 

         printf("Eh?\n");


2.2.1.2 Multibyte characters

   The source character set may contain multibyte characters, used to
represent members of the extended character set.  The execution
character set may also contain multibyte characters, which need not
have the same encoding as for the source character set.  For both
character sets, the following shall hold:

 * The single-byte characters defined in $2.2.1 shall be present.  

 * The presence, meaning, and representation of any additional members
   is locale-specific.

 * A multibyte character may have a state-dependent encoding ,wherein
   each sequence of multibyte characters begins in an initial shift state
   and enters other implementation-defined shift states when specific
   multibyte characters are encountered in the sequence.  While in the
   initial shift state, all single-byte characters retain their usual
   interpretation and do not alter the shift state.  The interpretation
   for subsequent bytes in the sequence is a function of the current
   shift state.

 * A byte with all bits zero shall be interpreted as a null character
   independent of shift state.

 * A byte with all bits zero shall not occur in the second or
   subsequent bytes of a multibyte character.

   For the source character set, the following shall hold: 

 * A comment, string literal, character constant, or header name shall
   begin and end in the initial shift state.

 * A comment, string literal, character constant, or header name shall
   consist of a sequence of valid multibyte characters.


2.2.2 Character display semantics

   The active position is that location on a display device where the
next character output by the fputc function would appear.  The intent
of writing a printable character (as defined by the isprint function)
to a display device is to display a graphic representation of that
character at the active position and then advance the active position
to the next position on the current line.  The direction of printing
is locale-specific.  If the active position is at the final position
of a line (if there is one), the behavior is unspecified.

   Alphabetic escape sequences representing nongraphic characters in
the execution character set are intended to produce actions on display
devices as follows: ( alert ) Produces an audible or visible alert.
The active position shall not be changed.  ( backspace ) Moves the
active position to the previous position on the current line.  If the
active position is at the initial position of a line, the behavior is
unspecified.  ( "form feed" ) Moves the active position to the initial
position at the start of the next logical page.  ( "new line" ) Moves
the active position to the initial position of the next line.  
( "carriage return" ) Moves the active position to the initial position
of the current line.  ( "horizontal tab" ) Moves the active position
to the next horizontal tabulation position on the current line.  If
the active position is at or past the last defined horizontal
tabulation position, the behavior is unspecified.  ( "vertical tab" )
Moves the active position to the initial position of the next vertical
tabulation position.  If the active position is at or past the last
defined vertical tabulation position, the behavior is unspecified.

   Each of these escape sequences shall produce a unique
implementation-defined value which can be stored in a single char
object.  The external representations in a text file need not be
identical to the internal representations, and are outside the scope
of this Standard.

Forward references: the fputc function ($4.9.7.3), the isprint
function ($4.3.1.7).


2.2.3 Signals and interrupts

   Functions shall be implemented such that they may be interrupted at
any time by a signal, or may be called by a signal handler, or both,
with no alteration to earlier, but still active, invocations' control
flow (after the interruption), function return values, or objects with
automatic storage duration.  All such objects shall be maintained
outside the function image (the instructions that comprise the
executable representation of a function) on a per-invocation basis.

   The functions in the standard library are not guaranteed to be
reentrant and may modify objects with static storage duration.


2.2.4 Environmental limits

   Both the translation and execution environments constrain the
implementation of language translators and libraries.  The following
summarizes the environmental limits on a conforming implementation.


2.2.4.1 Translation limits

   The implementation shall be able to translate and execute at least
one program that contains at least one instance of every one of the
following limits:/6/

 * 15 nesting levels of compound statements, iteration control
   structures, and selection control structures

 * 8 nesting levels of conditional inclusion 

 * 12 pointer, array, and function declarators (in any combinations)
   modifying an arithmetic, a structure, a union, or an incomplete type
   in a declaration

 * 31 declarators nested by parentheses within a full declarator 

 * 32 expressions nested by parentheses within a full expression 

 * 31 significant initial characters in an internal identifier or a
   macro name

 * 6 significant initial characters in an external identifier 

 * 511 external identifiers in one translation unit 

 * 127 identifiers with block scope declared in one block 

 * 1024 macro identifiers simultaneously defined in one translation unit 

 * 31 parameters in one function definition 

 * 31 arguments in one function call 

 * 31 parameters in one macro definition 

 * 31 arguments in one macro invocation 

 * 509 characters in a logical source line 

 * 509 characters in a character string literal or wide string literal
   (after concatenation)

 * 32767 bytes in an object (in a hosted environment only) 

 * 8 nesting levels for #include'd files 

 * 257 case labels for a switch statement (excluding those for any
   nested switch statements)

 * 127 members in a single structure or union 

 * 127 enumeration constants in a single enumeration 

 * 15 levels of nested structure or union definitions in a single
   struct-declaration-list


2.2.4.2 Numerical limits

   A conforming implementation shall document all the limits specified
in this section, which shall be specified in the headers <limits.h>
and <float.h> .

"Sizes of integral types <limits.h>"

   The values given below shall be replaced by constant expressions
suitable for use in #if preprocessing directives.  Their
implementation-defined values shall be equal or greater in magnitude
(absolute value) to those shown, with the same sign.

 * maximum number of bits for smallest object that is not a bit-field (byte) 
CHAR_BIT                         8 

 * minimum value for an object of type signed char 
SCHAR_MIN                     -127 

 * maximum value for an object of type signed char 
SCHAR_MAX                     +127 

 * maximum value for an object of type unsigned char 
UCHAR_MAX                      255 

 * minimum value for an object of type char 
CHAR_MIN                     see below 

 * maximum value for an object of type char 
CHAR_MAX                     see below 

 * maximum number of bytes in a multibyte character, for any supported locale 
MB_LEN_MAX                       1 

 * minimum value for an object of type short int 
SHRT_MIN                    -32767 

 * maximum value for an object of type short int 
SHRT_MAX                    +32767 

 * maximum value for an object of type unsigned short int 
USHRT_MAX                    65535 

 * minimum value for an object of type int 
INT_MIN                     -32767 

 * maximum value for an object of type int 
INT_MAX                     +32767 

 * maximum value for an object of type unsigned int 
UINT_MAX                     65535 

 * minimum value for an object of type long int 
LONG_MIN               -2147483647 

 * maximum value for an object of type long int 
LONG_MAX               +2147483647 

 * maximum value for an object of type unsigned long int 
ULONG_MAX               4294967295

   If the value of an object of type char sign-extends when used in an
expression, the value of CHAR_MIN shall be the same as that of
SCHAR_MIN and the value of CHAR_MAX shall be the same as that of
SCHAR_MAX .  If the value of an object of type char does not
sign-extend when used in an expression, the value of CHAR_MIN shall be
0 and the value of CHAR_MAX shall be the same as that of UCHAR_MAX
./7/

"Characteristics of floating types <float.h>"

   delim $$ The characteristics of floating types are defined in terms
of a model that describes a representation of floating-point numbers
and values that provide information about an implementation's
floating-point arithmetic.  The following parameters are used to
define the model for each floating-point type:

   A normalized floating-point number x ($f sub 1$ > 0 if x is defined
by the following model:/8/ $x~=~s~times~b sup e~times~sum from k=1 to
p~f sub k~times~b sup -k~,~~~e sub min~<=~e~<=~e sub max$

   Of the values in the <float.h> header, FLT_RADIX shall be a
constant expression suitable for use in #if preprocessing directives;
all other values need not be constant expressions.  All except
FLT_RADIX and FLT_ROUNDS have separate names for all three
floating-point types.  The floating-point model representation is
provided for all values except FLT_ROUNDS .

   The rounding mode for floating-point addition is characterized by
the value of FLT_ROUNDS : -1 indeterminable, 0 toward zero, 1 to nearest,
2 toward positive infinity, 3 toward negative infinity.  All other values
for FLT_ROUNDS characterize implementation-defined rounding behavior.

   The values given in the following list shall be replaced by
implementation-defined expressions that shall be equal or greater in
magnitude (absolute value) to those shown, with the same sign.

 * radix of exponent representation, b 
FLT_RADIX                        2 

 * number of base- FLT_RADIX digits in the floating-point mantissa, p 

FLT_MANT_DIG
DBL_MANT_DIG
LDBL_MANT_DIG



 * number of decimal digits of precision, $left floor~(p~-~1)~times~{
   log sub 10 } b~right floor ~+~ left { lpile { 1 above 0 } ~~ lpile {
   roman "if " b roman " is a power of 10" above roman otherwise }$

FLT_DIG                          6
DBL_DIG                         10
LDBL_DIG                        10



 * minimum negative integer such that FLT_RADIX raised to that power
   minus 1 is a normalized floating-point number, $e sub min$

FLT_MIN_EXP
DBL_MIN_EXP
LDBL_MIN_EXP



 * minimum negative integer such that 10 raised to that power is in
   the range of normalized floating-point numbers,

FLT_MIN_10_EXP                 -37
DBL_MIN_10_EXP                 -37
LDBL_MIN_10_EXP                -37



 * maximum integer such that FLT_RADIX raised to that power minus 1 is
   a representable finite floating-point number, $e sub max$

FLT_MAX_EXP
DBL_MAX_EXP
LDBL_MAX_EXP



 * maximum integer such that 10 raised to that power is in the range
   of representable finite floating-point numbers,

FLT_MAX_10_EXP                 +37
DBL_MAX_10_EXP                 +37
LDBL_MAX_10_EXP                +37


   The values given in the following list shall be replaced by
implementation-defined expressions with values that shall be equal to
or greater than those shown.

 * maximum representable finite floating-point number, 

FLT_MAX                      1E+37
DBL_MAX                      1E+37
LDBL_MAX                     1E+37


   The values given in the following list shall be replaced by
implementation-defined expressions with values that shall be equal to
or smaller than those shown.

 * minimum positive floating-point number x such that 1.0 + x 

FLT_EPSILON                   1E-5
DBL_EPSILON                   1E-9
LDBL_EPSILON                  1E-9



 * minimum normalized positive floating-point number, $b sup { e sub
   min - 1 }$

FLT_MIN                      1E-37
DBL_MIN                      1E-37
LDBL_MIN                     1E-37



Examples

   The following describes an artificial floating-point representation
that meets the minimum requirements of the Standard, and the
appropriate values in a <float.h> header for type float :
$x~=~s~times~16 sup e~times~sum from k=1 to 6~f sub k~times~16 sup
-k~,~~~-31~<=~e~<=~+32$
   

         FLT_RADIX                       16
         FLT_MANT_DIG                     6
         FLT_EPSILON        9.53674316E-07F
         FLT_DIG                          6
         FLT_MIN_EXP                    -31
         FLT_MIN            2.93873588E-39F
         FLT_MIN_10_EXP                 -38
         FLT_MAX_EXP                    +32
         FLT_MAX            3.40282347E+38F
         FLT_MAX_10_EXP                 +38


   The following describes floating-point representations that also
meet the requirements for single-precision and double-precision
normalized numbers in the IEEE Standard for Binary Floating-Point
Arithmetic (ANSI/IEEE Std 754-1985),/9/ b and the appropriate values
in a <float.h> header for types float and double : $x sub
f~=~s~times~2 sup e~times~{ sum from k=1 to 24~f sub k~times~2 sup -k
},~~~-125~<=~e~<=~+128$ $x sub d~=~s~times~2 sup e~times~{ sum from
k=1 to 53~f sub k~times~2 sup -k },~~~-1021~<=~e~<=~+1024$
   

         FLT_RADIX                        2
         FLT_MANT_DIG                    24
         FLT_EPSILON        1.19209290E-07F
         FLT_DIG                          6
         FLT_MIN_EXP                   -125
         FLT_MIN            1.17549435E-38F
         FLT_MIN_10_EXP                 -37
         FLT_MAX_EXP                   +128
         FLT_MAX            3.40282347E+38F
         FLT_MAX_10_EXP                 +38
         DBL_MANT_DIG                    53
         DBL_EPSILON 2.2204460492503131E-16
         DBL_DIG                         15
         DBL_MIN_EXP                  -1021
         DBL_MIN    2.2250738585072016E-308
         DBL_MIN_10_EXP                -307
         DBL_MAX_EXP                  +1024
         DBL_MAX    1.7976931348623157E+308
         DBL_MAX_10_EXP                +308


   The values shown above for FLT_EPSILON and DBL_EPSILON are
appropriate for the ANSI/IEEE Std 754-1985 default rounding mode (to
nearest).  Their values may differ for other rounding modes.

Forward references: conditional inclusion ($3.8.1).  conditional
inclusion ($3.8.1).


3. LANGUAGE

   In the syntax notation used in the language section ($3), syntactic
categories (nonterminals) are indicated by italic type, and literal
words and character set members (terminals) by bold type.  A colon (:)
following a nonterminal introduces its definition.  Alternative
definitions are listed on separate lines, except when prefaced by the
words ``one of.'' An optional symbol is indicated by the so that

         {  expression<opt> }

indicates an optional expression enclosed in braces.  

3.1 LEXICAL ELEMENTS


Syntax

          token:
                  keyword
                  identifier
                  constant
                  string-literal
                  operator
                  punctuator

          preprocessing-token:
                  header-name
                  identifier
                  pp-number
                  character-constant
                  string-literal
                  operator
                  punctuator
                  each non-white-space character that cannot be one of
                  the above



Constraints

   Each preprocessing token that is converted to a token shall have
the lexical form of a keyword, an identifier, a constant, a string
literal, an operator, or a punctuator.

Semantics

   A token is the minimal lexical element of the language in
translation phases 7 and 8.  The categories of tokens are: keywords,
identifiers, constants, string literals, operators, and punctuators.
A preprocessing token is the minimal lexical element of the language
in translation phases 3 through 6.  The categories of preprocessing
token are: header names, identifiers, preprocessing numbers,
character constants, string literals, operators, punctuators, and
single non-white-space characters that do not lexically match the
other preprocessing token categories.  If a ' or a " character matches
the last category, the behavior is undefined.  Comments (described
later) and the characters space, horizontal tab, new-line, vertical
tab, and form-feed---collectively called white space ---canseparate
preprocessing tokens.  As described in $3.8, in certain circumstances
during translation phase 4, white space (or the absence thereof)
serves as more than preprocessing token separation.  White space may
appear within a preprocessing token only as part of a header name or
between the quotation characters in a character constant or string
literal.

   If the input stream has been parsed into preprocessing tokens up to
a given character, the next preprocessing token is the longest
sequence of characters that could constitute a preprocessing token.

Examples

   The program fragment 1Ex is parsed as a preprocessing number token
(one that is not a valid floating or integer constant token), even
though a parse as the pair of preprocessing tokens 1 and Ex might
produce a valid expression (for example, if Ex were a macro defined as
+1 ).  Similarly, the program fragment 1E1 is parsed as a
preprocessing number (one that is a valid floating constant token),
whether or not E is a macro name.

   The program fragment x+++++y is parsed as x ++ ++ + y, which
violates a constraint on increment operators, even though the parse x
++ + ++ y might yield a correct expression.

Forward references: character constants ($3.1.3.4), comments ($3.1.9),
expressions ($3.3), floating constants ($3.1.3.1), header names
($3.1.7), macro replacement ($3.8.3), postfix increment and decrement
operators ($3.3.2.4), prefix increment and decrement operators
($3.3.3.1), preprocessing directives ($3.8), preprocessing numbers
($3.1.8), string literals ($3.1.4).


3.1.1 Keywords

Syntax

         keyword: one of

         auto     double   int      struct
         break    else     long     switch
         case     enum     register typedef
         char     extern   return   union
         const    float    short    unsigned
         continue for      signed   void
         default  goto     sizeof   volatile
         do       if       static   while



Semantics

   The above tokens (entirely in lower-case) are reserved (in
translation phases 7 and 8) for use as keywords, and shall not be used
otherwise.


3.1.2 Identifiers

Syntax

          identifier:
                  nondigit
                  identifier nondigit
                  identifier digit



          nondigit: one of
                  _  a  b  c  d  e  f  g  h  i  j  k  l  m
                     n  o  p  q  r  s  t  u  v  w  x  y  z
                     A  B  C  D  E  F  G  H  I  J  K  L  M
                     N  O  P  Q  R  S  T  U  V  W  X  Y  Z



          digit: one of
                  0  1  2  3  4  5  6  7  8  9



Description

   An identifier is a sequence of nondigit characters (including the
underscore _ and the lower-case and upper-case letters) and digits.
The first character shall be a nondigit character.

Constraints

   In translation phases 7 and 8, an identifier shall not consist of
the same sequence of characters as a keyword.

Semantics

   An identifier denotes an object, a function, or one of the
following entities that will be described later: a tag or a member of
a structure, union, or enumeration; a typedef name; a label name; a
macro name; or a macro parameter.  A member of an enumeration is
called an enumeration constant.  Macro names and macro parameters are
not considered further here, because prior to the semantic phase of
program translation any occurrences of macro names in the source file
are replaced by the preprocessing token sequences that constitute
their macro definitions.

   There is no specific limit on the maximum length of an identifier.  

"Implementation limits"

   The implementation shall treat at least the first 31 characters of
an internal name (a macro name or an identifier that does not have
external linkage) as significant.  Corresponding lower-case and
upper-case letters are different.  The implementation may further
restrict the significance of an external name (an identifier that has
external linkage) to six characters and may ignore distinctions of
alphabetical case for such names./10/ These limitations on identifiers
are all implementation-defined.

   Any identifiers that differ in a significant character are
different identifiers.  If two identifiers differ in a non-significant
character, the behavior is undefined.

Forward references: linkages of identifiers ($3.1.2.2), macro
replacement ($3.8.3).


3.1.2.1 Scopes of identifiers

   An identifier is visible (i.e., can be used) only within a region
of program text called its scope . There are four kinds of scopes:
function, file, block, and function prototype.  (A function prototype
is a declaration of a function that declares the types of its
parameters.)

   A label name is the only kind of identifier that has function scope.
It can be used (in a goto statement) anywhere in the function in
which it appears, and is declared implicitly by its syntactic
appearance (followed by a : and a statement).  Label names shall be
unique within a function.

   Every other identifier has scope determined by the placement of its
declaration (in a declarator or type specifier).  If the declarator or
type specifier that declares the identifier appears outside of any
block or list of parameters, the identifier has file scope, which
terminates at the end of the translation unit.  If the declarator or
type specifier that declares the identifier appears inside a block or
within the list of parameter declarations in a function definition,
the identifier has block scope, which terminates at the } that closes
the associated block.  If the declarator or type specifier that
declares the identifier appears within the list of parameter
declarations in a function prototype (not part of a function
definition), the identifier has function prototype scope ,which
terminates at the end of the function declarator.  If an outer
declaration of a lexically identical identifier exists in the same
name space, it is hidden until the current scope terminates, after
which it again becomes visible.

   Structure, union, and enumeration tags have scope that begins just
after the appearance of the tag in a type specifier that declares the
tag.  Each enumeration constant has scope that begins just after the
appearance of its defining enumerator in an enumerator list.  Any
other identifier has scope that begins just after the completion of
its declarator.

Forward references: compound statement, or block ($3.6.2),
declarations ($3.5), enumeration specifiers ($3.5.2.2), function calls
($3.3.2.2), function declarators (including prototypes) ($3.5.4.3),
function definitions ($3.7.1), the goto statement ($3.6.6.1), labeled
statements ($3.6.1), name spaces of identifiers ($3.1.2.3), scope of
macro definitions ($3.8.3.5), source file inclusion ($3.8.2), tags
($3.5.2.3), type specifiers ($3.5.2).

3.1.2.2 Linkages of identifiers

   An identifier declared in different scopes or in the same scope
more than once can be made to refer to the same object or function by
a process called linkage . There are three kinds of linkage: external,
internal, and none.

   In the set of translation units and libraries that constitutes an
entire program, each instance of a particular identifier with external
linkage denotes the same object or function.  Within one translation
unit, each instance of an identifier with internal linkage denotes the
same object or function.  Identifiers with no linkage denote unique
entities.

   If the declaration of an identifier for an object or a function has
file scope and contains the storage-class specifier static, the
identifier has internal linkage.

   If the declaration of an identifier for an object or a function
contains the storage-class specifier extern , the identifier has the
same linkage as any visible declaration of the identifier with file
scope.  If there is no visible declaration with file scope, the
identifier has external linkage.

   If the declaration of an identifier for a function has no
storage-class specifier, its linkage is determined exactly as if it
were declared with the storage-class specifier extern .  If the
declaration of an identifier for an object has file scope and no
storage-class specifier, its linkage is external.

   The following identifiers have no linkage: an identifier declared
to be anything other than an object or a function; an identifier
declared to be a function parameter; an identifier declared to be an
object inside a block without the storage-class specifier extern.

   If, within a translation unit, the same identifier appears with
both internal and external linkage, the behavior is undefined.

Forward references: compound statement, or block ($3.6.2),
declarations ($3.5), expressions ($3.3), external definitions ($3.7).


3.1.2.3 Name spaces of identifiers

   If more than one declaration of a particular identifier is visible
at any point in a translation unit, the syntactic context
disambiguates uses that refer to different entities.  Thus, there are
separate name spaces for various categories of identifiers, as
follows:

 * label names (disambiguated by the syntax of the label declaration
   and use);

 * the tags of structures, unions, and enumerations (disambiguated by
   following any/11/ of the keywords struct , union , or enum );

 * the members of structures or unions; each structure or union has a
   separate name space for its members (disambiguated by the type of the
   expression used to access the member via the .  or -> operator);

 * all other identifiers, called ordinary identifiers (declared in
   ordinary declarators or as enumeration constants).

Forward references: declarators ($3.5.4), enumeration specifiers
($3.5.2.2), labeled statements ($3.6.1), structure and union
specifiers ($3.5.2.1), structure and union members ($3.3.2.3), tags
($3.5.2.3).


3.1.2.4 Storage durations of objects

   An object has a storage duration that determines its lifetime.
There are two storage durations: static and automatic.

   An object declared with external or internal linkage, or with the
storage-class specifier static has static storage duration.  For such
an object, storage is reserved and its stored value is initialized
only once, prior to program startup.  The object exists and retains
its last-stored value throughout the execution of the entire
program./12/

   An object declared with no linkage and without the storage-class
specifier static has automatic storage duration. Storage is guaranteed
to be reserved for a new instance of such an object on each normal
entry into the block in which it is declared, or on a jump from
outside the block to a label in the block or in an enclosed block.  If
an initialization is specified for the value stored in the object, it
is performed on each normal entry, but not if the block is entered by
a jump to a label.  Storage for the object is no longer guaranteed to
be reserved when execution of the block ends in any way.  (Entering an
enclosed block suspends but does not end execution of the enclosing
block.  Calling a function that returns suspends but does not end
execution of the block containing the call.) The value of a pointer
that referred to an object with automatic storage duration that is no
longer guaranteed to be reserved is indeterminate.

Forward references: compound statement, or block ($3.6.2), function
calls ($3.3.2.2), initialization ($3.5.7).


3.1.2.5 Types

   The meaning of a value stored in an object or returned by a
function is determined by the type of the expression used to access
it.  (An identifier declared to be an object is the simplest such
expression; the type is specified in the declaration of the
identifier.) Types are partitioned into object types (types that
describe objects), function types (types that describe functions), and
incomplete types (types that describe objects but lack information
needed to determine their sizes).

   An object declared as type char is large enough to store any member
of the basic execution character set.  If a member of the required
source character set enumerated in $2.2.1 is stored in a char object,
its value is guaranteed to be positive.  If other quantities are
stored in a char object, the behavior is implementation-defined: the
values are treated as either signed or nonnegative integers.

   There are four signed integer types, designated as signed char, 
short int, int, and long int.  (The signed integer and other types
may be designated in several additional ways, as described in $3.5.2.)

   An object declared as type signed char occupies the same amount of
storage as a ``plain'' char object.  A ``plain'' int object has the
natural size suggested by the architecture of the execution
environment (large enough to contain any value in the range INT_MIN to
INT_MAX as defined in the header <limits.h> ).  In the list of signed
integer types above, the range of values of each type is a subrange of
the values of the next type in the list.

   For each of the signed integer types, there is a corresponding (but
different) unsigned integer type (designated with the keyword unsigned) 
that uses the same amount of storage (including sign information)
and has the same alignment requirements.  The range of nonnegative
values of a signed integer type is a subrange of the corresponding
unsigned integer type, and the representation of the same value in
each type is the same.  A computation involving unsigned operands can
never overflow, because a result that cannot be represented by the
resulting unsigned integer type is reduced modulo the number that is
one greater than the largest value that can be represented by the
resulting unsigned integer type.

   There are three floating types, designated as float , double , and
long double .  The set of values of the type float is a subset of the
set of values of the type double ; the set of values of the type
double is a subset of the set of values of the type long double.

   The type char, the signed and unsigned integer types, and the
floating types are collectively called the basic types. Even if the
implementation defines two or more basic types to have the same
representation, they are nevertheless different types.

   There are three character types, designated as char , signed char ,
and unsigned char.

   An enumeration comprises a set of named integer constant values.
Each distinct enumeration constitutes a different enumerated type.

   The void type comprises an empty set of values; it is an incomplete
type that cannot be completed.

   Any number of derived types can be constructed from the basic,
enumerated, and incomplete types, as follows:

 * An array type describes a contiguously allocated set of objects
   with a particular member object type, called the element type .Array
   types are characterized by their element type and by the number of
   members of the array.  An array type is said to be derived from its
   element type, and if its element type is T , the array type is
   sometimes called ``array of T .'' The construction of an array type
   from an element type is called ``array type derivation.''

 * A structure type describes a sequentially allocated set of member
   objects, each of which has an optionally specified name and possibly
   distinct type.

 * A union type describes an overlapping set of member objects, each
   of which has an optionally specified name and possibly distinct type.

 * A function type describes a function with specified return type.  A 
   function type is characterized by its return type and the number and
   types of its parameters.  A function type is said to be derived from
   its return type, and if its return type is T , the function type is
   sometimes called ``function returning T.'' The construction of a
   function type from a return type is called ``function type
   derivation.''

 * A pointer type may be derived from a function type, an object type,
   or an incomplete type, called the referenced type. A pointer type
   describes an object whose value provides a reference to an entity of
   the referenced type.  A pointer type derived from the referenced type
   T is sometimes called ``pointer to T .'' The construction of a pointer
   type from a referenced type is called ``pointer type derivation.''

   These methods of constructing derived types can be applied
recursively.

   The type char, the signed and unsigned integer types, and the
enumerated types are collectively called integral types. The
representations of integral types shall define values by use of a pure
binary numeration system./13/ American National Dictionary for
Information Processing Systems.) The representations of floating types
are unspecified.

   Integral and floating types are collectively called arithmetic
types.  Arithmetic types and pointer types are collectively called
scalar types.  Array and structure types are collectively called
aggregate types. /14/

   A pointer to void shall have the same representation and alignment
requirements as a pointer to a character type.  Other pointer types
need not have the same representation or alignment requirements.

   An array type of unknown size is an incomplete type.  It is
completed, for an identifier of that type, by specifying the size in a
later declaration (with internal or external linkage).  A structure or
union type of unknown content (as described in $3.5.2.3) is an
incomplete type.  It is completed, for all declarations of that type,
by declaring the same structure or union tag with its defining content
later in the same scope.

   Array, function, and pointer types are collectively called derived
declarator types. A declarator type derivation from a type T is the
construction of a derived declarator type from T by the application of
an array, a function, or a pointer type derivation to T.

   A type is characterized by its top type, which is either the first
type named in describing a derived type (as noted above in the
construction of derived types), or the type itself if the type
consists of no derived types.

   A type has qualified type if its top type is specified with a type
qualifier; otherwise it has unqualified type. The type qualifiers
const and volatile respectively designate const-qualified type and
volatile-qualified type. /15/ For each qualified type there is an
unqualified type that is specified the same way as the qualified type,
but without any type qualifiers in its top type.  This type is known
as the unqualified version of the qualified type.  Similarly, there
are appropriately qualified versions of types (such as a
const-qualified version of a type), just as there are appropriately
non-qualified versions of types (such as a non-const-qualified version
of a type).

Examples

   The type designated as ``float *'' is called ``pointer to float''
and its top type is a pointer type, not a floating type.  The
const-qualified version of this type is designated as ``float * const''
whereas the type designated as `` const float * '' is not a
qualified type --- it is called ``pointer to const float '' and is a
pointer to a qualified type.

   Finally, the type designated as `` struct tag (*[5])(float) '' is
called ``array of pointer to function returning struct tag.'' Its top
type is array type.  The array has length five and the function has a
single parameter of type float. 

Forward references: character constants ($3.1.3.4), declarations
($3.5), tags ($3.5.2.3), type qualifiers ($3.5.3).


3.1.2.6 Compatible type and composite type

   Two types have compatible type if their types are the same.
Additional rules for determining whether two types are compatible are
described in $3.5.2 for type specifiers, in $3.5.3 for type
qualifiers, and in $3.5.4 for declarators. /16/ Moreover, two
structure, union, or enumeration types declared in separate
translation units are compatible if they have the same number of
members, the same member names, and compatible member types; for two
structures, the members shall be in the same order; for two
enumerations, the members shall have the same values.

   All declarations that refer to the same object or function shall
have compatible type; otherwise the behavior is undefined.

   A composite type can be constructed from two types that are
compatible; it is a type that is compatible with both of the two types
and has the following additions:

 * If one type is an array of known size, the composite type is an
   array of that size.

 * If only one type is a function type with a parameter type list (a
   function prototype), the composite type is a function prototype with
   the parameter type list.

 * If both types have parameter type lists, the type of each parameter
   in the composite parameter type list is the composite type of the
   corresponding parameters.

   These rules apply recursively to the types from which the two types
are derived.

   For an identifier with external or internal linkage declared in the
same scope as another declaration for that identifier, the type of the
identifier becomes the composite type.

Example

   Given the following two file scope declarations: 

         int f(int (*)(), double (*)[3]);
         int f(int (*)(char *), double (*)[]);

The resulting composite type for the function is: 

         int f(int (*)(char *), double (*)[3]);

Forward references: declarators ($3.5.4), enumeration specifiers
($3.5.2.2), structure and union specifiers ($3.5.2.1), type
definitions ($3.5.6), type qualifiers ($3.5.3), type specifiers
($3.5.2).


3.1.3 Constants

Syntax

          constant:
                  floating-constant
                  integer-constant
                  enumeration-constant
                  character-constant

Constraints

   The value of a constant shall be in the range of representable
values for its type.

Semantics

   Each constant has a type, determined by its form and value, as
detailed later.


3.1.3.1 Floating constants

Syntax

          floating-constant:
                  fractional-constant exponent-part<opt> floating-suffix<opt>
                  digit-sequence exponent-part floating-suffix<opt>

          fractional-constant:
                  digit-sequence<opt>.digit-sequence
                  digit-sequence.

          exponent-part:
                  e  sign<opt> digit-sequence
                  E  sign<opt> digit-sequence

          sign: one of
                  +  -

          digit-sequence:
                  digit
                  digit-sequence digit

          floating-suffix: one of
                  f  l  F  L

Description

   A floating constant has a value part that may be followed by an
exponent part and a suffix that specifies its type.  The components of
the value part may include a digit sequence representing the
whole-number part, followed by a period (.), followed by a digit
sequence representing the fraction part.  The components of the
exponent part are an e or E followed by an exponent consisting of an
optionally signed digit sequence.  Either the whole-number part or the
fraction part shall be present; either the period or the exponent part
shall be present.

Semantics

   The value part is interpreted as a decimal rational number; the
digit sequence in the exponent part is interpreted as a decimal
integer.  The exponent indicates the power of 10 by which the value
part is to be scaled.  If the scaled value is in the range of
representable values (for its type) but cannot be represented exactly,
the result is either the nearest higher or nearest lower value, chosen
in an implementation-defined manner.

   An unsuffixed floating constant has type double.  If suffixed by
the letter f or F, it has type float.  If suffixed by the letter l
or L, it has type long double.


3.1.3.2 Integer constants

Syntax

          integer-constant:
                  decimal-constant integer-suffix<opt>
                  octal-constant integer-suffix<opt>
                  hexadecimal-constant integer-suffix<opt>

          decimal-constant:
                  nonzero-digit
                  decimal-constant digit

          octal-constant:
                  0 
                  octal-constant octal-digit

          hexadecimal-constant:
                  0x  hexadecimal-digit
                  0X  hexadecimal-digit
                  hexadecimal-constant hexadecimal-digit

          nonzero-digit: one of
                  1  2  3  4  5  6  7  8  9

          octal-digit: one of
                  0  1  2  3  4  5  6  7

          hexadecimal-digit: one of
                  0  1  2  3  4  5  6  7  8  9
                  a  b  c  d  e  f
                  A  B  C  D  E  F

          integer-suffix:
                  unsigned-suffix long-suffix<opt>
                  long-suffix unsigned-suffix<opt>

          unsigned-suffix: one of
                  u  U

          long-suffix: one of
                  l  L

Description

   An integer constant begins with a digit, but has no period or
exponent part.  It may have a prefix that specifies its base and a
suffix that specifies its type.

   A decimal constant begins with a nonzero digit and consists of a
sequence of decimal digits.  An octal constant consists of the prefix
0 optionally followed by a sequence of the digits 0 through 7 only.  A
hexadecimal constant consists of the prefix 0x or 0X followed by a
sequence of the decimal digits and the letters a (or A ) through f (or
F) with values 10 through 15 respectively.

Semantics

   The value of a decimal constant is computed base 10; that of an
octal constant, base 8; that of a hexadecimal constant, base 16.  The
lexically first digit is the most significant.

   The type of an integer constant is the first of the corresponding
list in which its value can be represented.  Unsuffixed decimal: int,
long int, unsigned long int; unsuffixed octal or hexadecimal: int,
unsigned int, long int, unsigned long int; suffixed by the letter u
or U: unsigned int, unsigned long int; suffixed by the letter l or
L: long int, unsigned long int; suffixed by both the letters u or U
and l or L: unsigned long int .


3.1.3.3 Enumeration constants

Syntax

          enumeration-constant:
                  identifier

Semantics

   An identifier declared as an enumeration constant has type int.  

Forward references: enumeration specifiers ($3.5.2.2).  


3.1.3.4 Character constants

Syntax

          character-constant:
                  ' c-char-sequence' 
                  L' c-char-sequence' 

          c-char-sequence:
                  c-char
                  c-char-sequence c-char

          c-char:
                  any member of the source character set except
                   the single-quote ', backslash \, or new-line character
                   escape-sequence

          escape-sequence:
                  simple-escape-sequence
                  octal-escape-sequence
                  hexadecimal-escape-sequence

          simple-escape-sequence: one of
                  \'  \"  \?  \\
                  \a  \b  \f  \n  \r  \t  \v

          octal-escape-sequence:
                  \  octal-digit
                  \  octal-digit octal-digit
                  \  octal-digit octal-digit octal-digit

          hexadecimal-escape-sequence:
                  \x  hexadecimal-digit
                  hexadecimal-escape-sequence hexadecimal-digit



Description

   An integer character constant is a sequence of one or more
multibyte characters enclosed in single-quotes, as in 'x' or 'ab'.  A
wide character constant is the same, except prefixed by the letter L .
With a few exceptions detailed later, the elements of the sequence are
any members of the source character set; they are mapped in an
implementation-defined manner to members of the execution character
set.

   The single-quote ', the double-quote , the question-mark ?, the
backslash \ , and arbitrary integral values, are representable
according to the following table of escape sequences:

         single-quote '       \'
         double-quote "       \"
         question-mark ?      \?
         backslash \          \\
         octal integer        \ octal digits
         hexadecimal integer  \x hexadecimal digits

   The double-quote and question-mark ? are representable either by
themselves or by the escape sequences \" and \? respectively, but the
single-quote ' and the backslash \ shall be represented, respectively,
by the escape sequences \' and \\ .

   The octal digits that follow the backslash in an octal escape
sequence are taken to be part of the construction of a single
character for an integer character constant or of a single wide
character for a wide character constant.  The numerical value of the
octal integer so formed specifies the value of the desired character.

   The hexadecimal digits that follow the backslash and the letter x
in a hexadecimal escape sequence are taken to be part of the
construction of a single character for an integer character constant
or of a single wide character for a wide character constant.  The
numerical value of the hexadecimal integer so formed specifies the
value of the desired character.

   Each octal or hexadecimal escape sequence is the longest sequence
of characters that can constitute the escape sequence.

   In addition, certain nongraphic characters are representable by
escape sequences consisting of the backslash \ followed by a
lower-case letter: \a , \b , \f , \n , \r , \t , and \v ./17/ If any
other escape sequence is encountered, the behavior is undefined./18/

Constraints

   The value of an octal or hexadecimal escape sequence shall be in
the range of representable values for the unsigned type corresponding
to its type.

Semantics

   An integer character constant has type int.  The value of an
integer character constant containing a single character that maps
into a member of the basic execution character set is the numerical
value of the representation of the mapped character interpreted as an
integer.  The value of an integer character constant containing more
than one character, or containing a character or escape sequence not
represented in the basic execution character set, is
implementation-defined.  In particular, in an implementation in which
type char has the same range of values as signed char, the high-order
bit position of a single-character integer character constant is
treated as a sign bit.

   A wide character constant has type wchar_t , an integral type
defined in the <stddef.h> header.  The value of a wide character
constant containing a single multibyte character that maps into a
member of the extended execution character set is the wide character
(code) corresponding to that multibyte character, as defined by the
mbtowc function, with an implementation-defined current locale.  The
value of a wide character constant containing more than one multibyte
character, or containing a multibyte character or escape sequence not
represented in the extended execution character set, is
implementation-defined.

Examples

   The construction '\0' is commonly used to represent the null character.

   Consider implementations that use two's-complement representation
for integers and eight bits for objects that have type char.  In an
implementation in which type char has the same range of values as
signed char, the integer character constant '\xFF' has the value if
type char has the same range of values as unsigned char, the
character constant '\xFF' has the value

   Even if eight bits are used for objects that have type char , the
construction '\x123' specifies an integer character constant
containing only one character.  (The value of this single-character
integer character constant is implementation-defined and violates the
above constraint.) To specify an integer character constant containing
the two characters whose values are 0x12 and '3', the construction
'\0223' may be used, since a hexadecimal escape sequence is terminated
only by a non-hexadecimal character.  (The value of this two-character
integer character constant is implementation-defined also.)

   Even if 12 or more bits are used for objects that have type wchar_t,
the construction L'\1234' specifies the implementation-defined value
that results from the combination of the values 0123 and '4'.

Forward references: characters and integers ($3.2.1.1) common
definitions <stddef.h> ($4.1.5), the mbtowc function ($4.10.7.2).


3.1.4 String literals

Syntax

          string-literal:
                  " s-char-sequence<opt>"
                  L" s-char-sequence<opt>"

          s-char-sequence:
                  s-char
                  s-char-sequence s-char

          s-char:
                  any member of the source character set except
                   the double-quote ", backslash \, or new-line character
                   escape-sequence

Description

   A character string literal is a sequence of zero or more multibyte
characters enclosed in double-quotes, as in xyz.  A wide string
literal is the same, except prefixed by the letter L.

   The same considerations apply to each element of the sequence in a
character string literal or a wide string literal as if it were in an
integer character constant or a wide character constant, except that
the single-quote ' is representable either by itself or by the escape
sequence \', but the double-quote shall be represented by the escape
sequence \.

Semantics

   A character string literal has static storage duration and type
``array of char ,'' and is initialized with the given characters.  A
wide string literal has static storage duration and type ``array of
wchar_t,'' and is initialized with the wide characters corresponding
to the given multibyte characters.  Character string literals that are
adjacent tokens are concatenated into a single character string
literal.  A null character is then appended. /19/ Likewise, adjacent
wide string literal tokens are concatenated into a single wide string
literal to which a code with value zero is then appended.  If a
character string literal token is adjacent to a wide string literal
token, the behavior is undefined.

   Identical string literals of either form need not be distinct.  If
the program attempts to modify a string literal of either form, the
behavior is undefined.

Example

   This pair of adjacent character string literals 

         "\x12" "3"

produces a single character string literal containing the two
characters whose values are \x12 and '3', because escape sequences are
converted into single members of the execution character set just
prior to adjacent string literal concatenation.

Forward references: common definitions <stddef.h> ($4.1.5).  


3.1.5 Operators

Syntax

          operator: one of
                  [  ]  (  )  .  ->
                  ++  --  &  *  +  -  ~  !  sizeof
                  /  %  <<  >>  <  >  <=  >=  ==  !=  ^  |  &&  ||
                  ?  :
                  =  *=  /=  %=  +=  -=  <<=  >>=  &=  ^=  |=
                  ,  #  ##

Constraints

   The operators [ ] , ( ) , and ? : shall occur in pairs, possibly
separated by expressions.  The operators # and ## shall occur in
macro-defining preprocessing directives only.

Semantics

   An operator specifies an operation to be performed (an evaluation )
that yields a value, or yields a designator, or produces a side
effect, or a combination thereof.  An operand is an entity on which an
operator acts.

Forward references: expressions ($3.3), macro replacement ($3.8.3).  

3.1.6 Punctuators


Syntax

          punctuator: one of
                  [  ]  (  )  {  }  *  ,  :  =  ;  ...  #

Constraints

   The punctuators [ ] , ( ) , and { } shall occur in pairs, possibly
separated by expressions, declarations, or statements.  The punctuator
# shall occur in preprocessing directives only.

Semantics

   A punctuator is a symbol that has independent syntactic and
semantic significance but does not specify an operation to be
performed that yields a value.  Depending on context, the same symbol
may also represent an operator or part of an operator.

Forward references: expressions ($3.3), declarations ($3.5),
preprocessing directives ($3.8), statements ($3.6).

3.1.7 Header names

Syntax

          header-name:
                  < h-char-sequence>
                  " q-char-sequence"

          h-char-sequence:
                  h-char
                  h-char-sequence h-char

          h-char:
                  any member of the source character set except
                           the new-line character and >

          q-char-sequence:
                  q-char
                  q-char-sequence q-char

          q-char:
                  any member of the source character set except
                           the new-line character and "


Constraints

   Header name preprocessing tokens shall only appear within a
#include preprocessing directive.

Semantics

   The sequences in both forms of header names are mapped in an
implementation-defined manner to headers or external source file names
as specified in $3.8.2.

   If the characters ', \ , , or /* occur in the sequence between the
< and > delimiters, the behavior is undefined.  Similarly, if the
characters ', \ , or /* occur in the sequence between the " delimiters,
the behavior is undefined. /20/

Example

   The following sequence of characters: 

         0x3<1/a.h>1e2
         #include <1/a.h>
         #define const.member@$

forms the following sequence of preprocessing tokens (with each
individual preprocessing token delimited by a { on the left and a } on
the right).

         {0x3}{<}{1}{/}{a}{.}{h}{>}{1e2}
         {#}{include} {<1/a.h>}
         {#}{define} {const}{.}{member}{@}{$}

Forward references: source file inclusion ($3.8.2).  


3.1.8 Preprocessing numbers

Syntax

          pp-number:
                  digit
                  .  digit
                  pp-number  digit
                  pp-number  nondigit
                  pp-number e  sign
                  pp-number E  sign
                  pp-number .

Description

   A preprocessing number begins with a digit optionally preceded by a
period (.) and may be followed by letters, underscores, digits,
periods, and e+, e-, E+, or E- character sequences.

   Preprocessing number tokens lexically include all floating and
integer constant tokens.

Semantics

   A preprocessing number does not have type or a value; it acquires
both after a successful conversion (as part of translation phase 7) to
a floating constant token or an integer constant token.


3.1.9 Comments

   Except within a character constant, a string literal, or a comment,
the characters /* introduce a comment.  The contents of a comment are
examined only to identify multibyte characters and to find the
characters */ that terminate it. /21/


3.2 CONVERSIONS

   Several operators convert operand values from one type to another
automatically.  This section specifies the result required from such
an implicit conversion, as well as those that result from a cast
operation (an explicit conversion).  The list in $3.2.1.5 summarizes
the conversions performed by most ordinary operators; it is
supplemented as required by the discussion of each operator in $3.3.

   Conversion of an operand value to a compatible type causes no change.  

Forward references: cast operators ($3.3.4).  


3.2.1 Arithmetic operands

3.2.1.1 Characters and integers

   A char, a short int, or an int bit-field, or their signed or
unsigned varieties, or an object that has enumeration type, may be
used in an expression wherever an int or unsigned int may be used.  If
an int can represent all values of the original type, the value is
converted to an int; otherwise it is converted to an unsigned int.
These are called the integral promotions.

   The integral promotions preserve value including sign.  As
discussed earlier, whether a ``plain'' char is treated as signed is
implementation-defined.

Forward references: enumeration specifiers ($3.5.2.2), structure and
union specifiers ($3.5.2.1).


3.2.1.2 Signed and unsigned integers

   When an unsigned integer is converted to another integral type, if
the value can be represented by the new type, its value is unchanged.

   When a signed integer is converted to an unsigned integer with
equal or greater size, if the value of the signed integer is
nonnegative, its value is unchanged.  Otherwise: if the unsigned
integer has greater size, the signed integer is first promoted to the
signed integer corresponding to the unsigned integer; the value is
converted to unsigned by adding to it one greater than the largest
number that can be represented in the unsigned integer type. /22/

   When an integer is demoted to an unsigned integer with smaller
size, the result is the nonnegative remainder on division by the
number one greater than the largest unsigned number that can be
represented in the type with smaller size.  When an integer is demoted
to a signed integer with smaller size, or an unsigned integer is
converted to its corresponding signed integer, if the value cannot be
represented the result is implementation-defined.


3.2.1.3 Floating and integral

   When a value of floating type is converted to integral type, the
fractional part is discarded.  If the value of the integral part
cannot be represented by the integral type, the behavior is
undefined. /23/

   When a value of integral type is converted to floating type, if the
value being converted is in the range of values that can be
represented but cannot be represented exactly, the result is either
the nearest higher or nearest lower value, chosen in an
implementation-defined manner.


3.2.1.4 Floating types

   When a float is promoted to double or long double , or a double is
promoted to long double , its value is unchanged.

   When a double is demoted to float or a long double to double or
float, if the value being converted is outside the range of values
that can be represented, the behavior is undefined.  If the value
being converted is in the range of values that can be represented but
cannot be represented exactly, the result is either the nearest higher
or nearest lower value, chosen in an implementation-defined manner.


3.2.1.5 Usual arithmetic conversions

   Many binary operators that expect operands of arithmetic type cause
conversions and yield result types in a similar way.  The purpose is
to yield a common type, which is also the type of the result.  This
pattern is called the usual arithmetic conversions: First, if either
operand has type long double, the other operand is converted to long
double .  Otherwise, if either operand has type double, the other
operand is converted to double.  Otherwise, if either operand has
type float, the other operand is converted to float.  Otherwise, the
integral promotions are performed on both operands.  Then the
following rules are applied: If either operand has type unsigned long
int, the other operand is converted to unsigned long int.
Otherwise, if one operand has type long int and the other has type
unsigned int, if a long int can represent all values of an unsigned
int, the operand of type unsigned int is converted to long int ; if a
long int cannot represent all the values of an unsigned int, both
operands are converted to unsigned long int.  Otherwise, if either
operand has type long int, the other operand is converted to long int.
Otherwise, if either operand has type unsigned int, the other
operand is converted to unsigned int.  Otherwise, both operands have
type int.

   The values of operands and of the results of expressions may be
represented in greater precision and range than that required by the
type; the types are not changed thereby.


3.2.2 Other operands

3.2.2.1 Lvalues and function designators

   An lvalue is an expression (with an object type or an incomplete
type other than void) that designates an object. /24/ When an object
is said to have a particular type, the type is specified by the lvalue
used to designate the object.  A modifiable lvalue is an lvalue that
does not have array type, does not have an incomplete type, does not
have a const-qualified type, and if it is a structure or union, does
not have any member (including, recursively, any member of all
contained structures or unions) with a const-qualified type.

   Except when it is the operand of the sizeof operator, the unary &
operator, the ++ operator, the -- operator, or the left operand of the .
operator or an assignment operator, an lvalue that does not have
array type is converted to the value stored in the designated object
(and is no longer an lvalue).  If the lvalue has qualified type, the
value has the unqualified version of the type of the lvalue; otherwise
the value has the type of the lvalue.  If the lvalue has an incomplete
type and does not have array type, the behavior is undefined.

   Except when it is the operand of the sizeof operator or the unary &
operator, or is a character string literal used to initialize an array
of character type, or is a wide string literal used to initialize an
array with element type compatible with wchar_t, an lvalue that has
type ``array of type '' is converted to an expression that has type
``pointer to type '' that points to the initial member of the array
object and is not an lvalue.

   A function designator is an expression that has function type.
Except when it is the operand of the sizeof operator /25/ or the unary
& operator, a function designator with type ``function returning type
'' is converted to an expression that has type ``pointer to function
returning type .''

Forward references: address and indirection operators ($3.3.3.2),
assignment operators ($3.3.16), common definitions <stddef.h>
($4.1.5), initialization ($3.5.7), postfix increment and decrement
operators ($3.3.2.4), prefix increment and decrement operators
($3.3.3.1), the sizeof operator ($3.3.3.4), structure and union
members ($3.3.2.3).


3.2.2.2 void

   The (nonexistent) value of a void expression (an expression that
has type void) shall not be used in any way, and implicit or explicit
conversions (except to void ) shall not be applied to such an
expression.  If an expression of any other type occurs in a context
where a void expression is required, its value or designator is
discarded.  (A void expression is evaluated for its side effects.)


3.2.2.3 Pointers

   A pointer to void may be converted to or from a pointer to any
incomplete or object type.  A pointer to any incomplete or object type
may be converted to a pointer to void and back again; the result shall
compare equal to the original pointer.

   A pointer to a non-q-qualified type may be converted to a pointer
to the q-qualified version of the type; the values stored in the
original and converted pointers shall compare equal.

   An integral constant expression with the value 0, or such an
expression cast to type void * , is called a null pointer constant.  If
a null pointer constant is assigned to or compared for equality to a
pointer, the constant is converted to a pointer of that type.  Such a
pointer, called a null pointer, is guaranteed to compare unequal to a
pointer to any object or function.

   Two null pointers, converted through possibly different sequences
of casts to pointer types, shall compare equal.

Forward references: cast operators ($3.3.4), equality operators
($3.3.9), simple assignment ($3.3.16.1).


3.3 EXPRESSIONS

   An expression is a sequence of operators and operands that
specifies computation of a value, or that designates an object or a
function, or that generates side effects, or that performs a
combination thereof.

   Between the previous and next sequence point an object shall have
its stored value modified at most once by the evaluation of an
expression.  Furthermore, the prior value shall be accessed only to
determine the value to be stored. /26/

   Except as indicated by the syntax /27/ or otherwise specified later
(for the function-call operator () , && , || , ?: , and comma
operators), the order of evaluation of subexpressions and the order in
which side effects take place are both unspecified.

   Some operators (the unary operator ~ , and the binary operators << ,
>> , & , ^ , and | , collectively described as bitwise operators
)shall have operands that have integral type.  These operators return
values that depend on the internal representations of integers, and
thus have implementation-defined aspects for signed types.

   If an exception occurs during the evaluation of an expression (that
is, if the result is not mathematically defined or not representable),
the behavior is undefined.

   An object shall have its stored value accessed only by an lvalue
that has one of the following types: /28/

 * the declared type of the object, 

 * a qualified version of the declared type of the object, 

 * a type that is the signed or unsigned type corresponding to the
   declared type of the object,

 * a type that is the signed or unsigned type corresponding to a
   qualified version of the declared type of the object,

 * an aggregate or union type that includes one of the aforementioned
   types among its members (including, recursively, a member of a
   subaggregate or contained union), or

 * a character type.  


3.3.1 Primary expressions

Syntax

          primary-expression:
                  identifier
                  constant
                  string-literal
                  (  expression )

Semantics

   An identifier is a primary expression, provided it has been
declared as designating an object (in which case it is an lvalue) or a
function (in which case it is a function designator).

   A constant is a primary expression.  Its type depends on its form,
as detailed in $3.1.3.

   A string literal is a primary expression.  It is an lvalue with
type as detailed in $3.1.4.

   A parenthesized expression is a primary expression.  Its type and
value are identical to those of the unparenthesized expression.  It is
an lvalue, a function designator, or a void expression if the
unparenthesized expression is, respectively, an lvalue, a function
designator, or a void expression.

Forward references: declarations ($3.5).  


3.3.2 Postfix operators

Syntax

          postfix-expression:
                  primary-expression
                  postfix-expression [  expression ] 
                  postfix-expression (  argument-expression-list<opt> ) 
                  postfix-expression .   identifier
                  postfix-expression ->  identifier
                  postfix-expression ++ 
                  postfix-expression --

          argument-expression-list:
                  assignment-expression
                  argument-expression-list ,  assignment-expression


3.3.2.1 Array subscripting

Constraints

   One of the expressions shall have type ``pointer to object type ,''
the other expression shall have integral type, and the result has type
`` type .''

Semantics

   A postfix expression followed by an expression in square brackets
[] is a subscripted designation of a member of an array object.  The
definition of the subscript operator [] is that E1[E2] is identical to
(*(E1+(E2))) .  Because of the conversion rules that apply to the
binary + operator, if E1 is an array object (equivalently, a pointer
to the initial member of an array object) and E2 is an integer, E1[E2]
designates the E2 -th member of E1 (counting from zero).

   Successive subscript operators designate a member of a
multi-dimensional array object.  If E is an n -dimensional array ( n
>=2) with dimensions i x j "x ... x" k , then E (used as other than an
lvalue) is converted to a pointer to an ( n -1)-dimensional array with
dimensions j "x ... x" k . If the unary * operator is applied to this
pointer explicitly, or implicitly as a result of subscripting, the
result is the pointed-to ( n -1)-dimensional array, which itself is
converted into a pointer if used as other than an lvalue.  It follows
from this that arrays are stored in row-major order (last subscript
varies fastest).

Example

   Consider the array object defined by the declaration 

         int x[3][5];

Here x is a 3x5 array of int s; more precisely, x is an array of three
member objects, each of which is an array of five int s.  In the
expression x[i] , which is equivalent to (*(x+(i))) , x is first
converted to a pointer to the initial array of five int s.  Then i is
adjusted according to the type of x , which conceptually entails
multiplying i by the size of the object to which the pointer points,
namely an array of five int objects.  The results are added and
indirection is applied to yield an array of five int s.  When used in
the expression x[i][j] , that in turn is converted to a pointer to the
first of the int s, so x[i][j] yields an int.

Forward references: additive operators ($3.3.6), address and
indirection operators ($3.3.3.2), array declarators ($3.5.4.2).


3.3.2.2 Function calls

Constraints

   The expression that denotes the called function/29/ shall have type
pointer to function returning void or returning an object type other
than array.

   If the expression that denotes the called function has a type that
includes a prototype, the number of arguments shall agree with the
number of parameters.  Each argument shall have a type such that its
value may be assigned to an object with the unqualified version of the
type of its corresponding parameter.

Semantics

   A postfix expression followed by parentheses () containing a
possibly empty, comma-separated list of expressions is a function
call.  The postfix expression denotes the called function.  The list
of expressions specifies the arguments to the function.

   If the expression that precedes the parenthesized argument list in
a function call consists solely of an identifier, and if no
declaration is visible for this identifier, the identifier is
implicitly declared exactly as if, in the innermost block containing
the function call, the declaration

         extern int  identifier();

appeared. /30/

   An argument may be an expression of any object type.  In preparing
for the call to a function, the arguments are evaluated, and each
parameter is assigned the value of the corresponding argument./31/ The
value of the function call expression is specified in $3.6.6.4.

   If the expression that denotes the called function has a type that
does not include a prototype, the integral promotions are performed on
each argument and arguments that have type float are promoted to
double.  These are called the default argument promotions.  If the
number of arguments does not agree with the number of parameters, the
behavior is undefined.  If the function is defined with a type that
does not include a prototype, and the types of the arguments after
promotion are not compatible with those of the parameters after
promotion, the behavior is undefined.  If the function is defined with
a type that includes a prototype, and the types of the arguments after
promotion are not compatible with the types of the parameters, or if
the prototype ends with an ellipsis ( ", ..." ), the behavior is
undefined.

   If the expression that denotes the called function has a type that
includes a prototype, the arguments are implicitly converted, as if by
assignment, to the types of the corresponding parameters.  The
ellipsis notation in a function prototype declarator causes argument
type conversion to stop after the last declared parameter.  The
default argument promotions are performed on trailing arguments.  If
the function is defined with a type that is not compatible with the
type (of the expression) pointed to by the expression that denotes the
called function, the behavior is undefined.

   No other conversions are performed implicitly; in particular, the
number and types of arguments are not compared with those of the
parameters in a function definition that does not include a function
prototype declarator.

   The order of evaluation of the function designator, the arguments,
and subexpressions within the arguments is unspecified, but there is a
sequence point before the actual call.

   Recursive function calls shall be permitted, both directly and
indirectly through any chain of other functions.

Example

   In the function call 

         (*pf[f1()]) (f2(), f3() + f4())

the functions f1 , f2 , f3 , and f4 may be called in any order.  All
side effects shall be completed before the function pointed to by
pf[f1()] is entered.

Forward references: function declarators (including prototypes)
($3.5.4.3), function definitions ($3.7.1), the return statement
($3.6.6.4), simple assignment ($3.3.16.1).


3.3.2.3 Structure and union members

Constraints

   The first operand of the .  operator shall have a qualified or
unqualified structure or union type, and the second operand shall name
a member of that type.

   The first operand of the -> operator shall have type ``pointer to
qualified or unqualified structure'' or ``pointer to qualified or
unqualified union,'' and the second operand shall name a member of the
type pointed to.

Semantics

   A postfix expression followed by a dot .  and an identifier
designates a member of a structure or union object.  The value is that
of the named member, and is an lvalue if the first expression is an
lvalue.  If the first expression has qualified type, the result has
the so-qualified version of the type of the designated member.

   A postfix expression followed by an arrow -> and an identifier
designates a member of a structure or union object.  The value is that
of the named member of the object to which the first expression
points, and is an lvalue./32/ If the first expression is a pointer to
a qualified type, the result has the so-qualified version of the type
of the designated member.

   With one exception, if a member of a union object is accessed after
a value has been stored in a different member of the object, the
behavior is implementation-defined./33/ One special guarantee is made
in order to simplify the use of unions: If a union contains several
structures that share a common initial sequence, and if the union
object currently contains one of these structures, it is permitted to
inspect the common initial part of any of them.  Two structures share
a common initial sequence if corresponding members have compatible
types for a sequence of one or more initial members.

Example

   If f is a function returning a structure or union, and x is a
member of that structure or union, f().x is a valid postfix expression
but is not an lvalue.

   The following is a valid fragment: 

         union {
                  struct {
                           int      alltypes;
                  } n;
                  struct {
                           int      type;
                           int      intnode;
                  } ni;
                  struct {
                           int      type;
                           double   doublenode;
                  } nf;
         } u;
         /*...*/
         u.nf.type = 1;
         u.nf.doublenode = 3.14;
         /*...*/
         if (u.n.alltypes == 1)
                  /*...*/ sin(u.nf.doublenode) /*...*/



Forward references: address and indirection operators ($3.3.3.2),
structure and union specifiers ($3.5.2.1).


3.3.2.4 Postfix increment and decrement operators

Constraints

   The operand of the postfix increment or decrement operator shall
have qualified or unqualified scalar type and shall be a modifiable
lvalue.

Semantics

   The result of the postfix ++ operator is the value of the operand.
After the result is obtained, the value of the operand is incremented.
(That is, the value 1 of the appropriate type is added to it.) See the
discussions of additive operators and compound assignment for
information on constraints, types and conversions and the effects of
operations on pointers.  The side effect of updating the stored value
of the operand shall occur between the previous and the next sequence
point.

   The postfix -- operator is analogous to the postfix ++ operator,
except that the value of the operand is decremented (that is, the
value 1 of the appropriate type is subtracted from it).

Forward references: additive operators ($3.3.6), compound assignment
($3.3.16.2).


3.3.3 Unary operators

Syntax

          unary-expression:
                  postfix-expression
                  ++  unary-expression
                  --  unary-expression
                  unary-operator cast-expression
                  sizeof  unary-expression
                  sizeof (  type-name )

          unary-operator: one of
                  &  *  +  -  ~  !


3.3.3.1 Prefix increment and decrement operators

Constraints

   The operand of the prefix increment or decrement operator shall
have qualified or unqualified scalar type and shall be a modifiable
lvalue.

Semantics

   The value of the operand of the prefix ++ operator is incremented.
The result is the new value of the operand after incrementation.  The
expression ++E is equivalent to (E+=1) .  See the discussions of
additive operators and compound assignment for information on
constraints, types, side effects, and conversions and the effects of
operations on pointers.

   The prefix -- operator is analogous to the prefix ++ operator,
except that the value of the operand is decremented.

Forward references: additive operators ($3.3.6), compound assignment
($3.3.16.2).


3.3.3.2 Address and indirection operators

Constraints

   The operand of the unary & operator shall be either a function
designator or an lvalue that designates an object that is not a
bit-field and is not declared with the register storage-class
specifier.

   The operand of the unary * operator shall have pointer type.  

Semantics

   The result of the unary & (address-of) operator is a pointer to the
object or function designated by its operand.  If the operand has type
`` type ,'' the result has type ``pointer to type .''

   The unary * operator denotes indirection.  If the operand points to
a function, the result is a function designator; if it points to an
object, the result is an lvalue designating the object.  If the
operand has type ``pointer to type ,'' the result has type `` type .''
If an invalid value has been assigned to the pointer, the behavior of
the unary * operator is undefined./34/

Forward references: storage-class specifiers ($3.5.1), structure and
union specifiers ($3.5.2.1).


3.3.3.3 Unary arithmetic operators

Constraints

   The operand of the unary + or - operator shall have arithmetic
type; of the ~ operator, integral type; of the ! operator, scalar
type.

Semantics

   The result of the unary + operator is the value of its operand.
The integral promotion is performed on the operand, and the result has
the promoted type.

   The result of the unary - operator is the negative of its operand.
The integral promotion is performed on the operand, and the result has
the promoted type.

   The result of the ~ operator is the bitwise complement of its
operand (that is, each bit in the result is set if and only if the
corresponding bit in the converted operand is not set).  The integral
promotion is performed on the operand, and the result has the promoted
type.  The expression ~E is equivalent to (ULONG_MAX-E) if E is
promoted to type unsigned long , to (UINT_MAX-E) if E is promoted to
type unsigned int .  (The constants ULONG_MAX and UINT_MAX are defined
in the header <limits.h> .)

   The result of the logical negation operator ! is 0 if the value of
its operand compares unequal to 0, 1 if the value of its operand
compares equal to 0.  The result has type int .  The expression !E is
equivalent to (0==E) .

Forward references: limits <float.h> and <limits.h> ($4.1.4).  


3.3.3.4 The sizeof operator

Constraints

   The sizeof operator shall not be applied to an expression that has
function type or an incomplete type, to the parenthesized name of such
a type, or to an lvalue that designates a bit-field object.

Semantics

   The sizeof operator yields the size (in bytes) of its operand,
which may be an expression or the parenthesized name of a type.  The
size is determined from the type of the operand, which is not itself
evaluated.  The result is an integer constant.

   When applied to an operand that has type char , unsigned char , or
signed char , (or a qualified version thereof) the result is 1.  When
applied to an operand that has array type, the result is the total
number of bytes in the array./35/ When applied to an operand that has
structure or union type, the result is the total number of bytes in
such an object, including internal and trailing padding.

   The value of the result is implementation-defined, and its type (an
unsigned integral type) is size_t defined in the <stddef.h> header.

Examples

   A principal use of the sizeof operator is in communication with
routines such as storage allocators and I/O systems.  A
storage-allocation function might accept a size (in bytes) of an
object to allocate and return a pointer to void.  For example:

         extern void *alloc();
         double *dp = alloc(sizeof *dp);

The implementation of the alloc function should ensure that its return
value is aligned suitably for conversion to a pointer to double.

   Another use of the sizeof operator is to compute the number of
members in an array:

         sizeof array / sizeof array[0]

Forward references: common definitions <stddef.h> ($4.1.5),
declarations ($3.5), structure and union specifiers ($3.5.2.1), type
names ($3.5.5).


3.3.4 Cast operators

Syntax

          cast-expression:
                  unary-expression
                  ( type-name )  cast-expression

Constraints

   Unless the type name specifies void type, the type name shall
specify qualified or unqualified scalar type and the operand shall
have scalar type.

Semantics

   Preceding an expression by a parenthesized type name converts the
value of the expression to the named type.  This construction is
called a cast. /36/ A cast that specifies an implicit conversion or no
conversion has no effect on the type or value of an expression.

   Conversions that involve pointers (other than as permitted by the
constraints of $3.3.16.1) shall be specified by means of an explicit
cast; they have implementation-defined aspects: A pointer may be
converted to an integral type.  The size of integer required and the
result are implementation-defined.  If the space provided is not long
enough, the behavior is undefined.  An arbitrary integer may be
converted to a pointer.  The result is implementation-defined./37/ A
pointer to an object or incomplete type may be converted to a pointer
to a different object type or a different incomplete type.  The
resulting pointer might not be valid if it is improperly aligned for
the type pointed to.  It is guaranteed, however, that a pointer to an
object of a given alignment may be converted to a pointer to an object
of the same alignment or a less strict alignment and back again; the
result shall compare equal to the original pointer.  (An object that
has character type has the least strict alignment.) A pointer to a
function of one type may be converted to a pointer to a function of
another type and back again; the result shall compare equal to the
original pointer.  If a converted pointer is used to call a function
that has a type that is not compatible with the type of the called
function, the behavior is undefined.

Forward references: equality operators ($3.3.9), function declarators
(including prototypes) ($3.5.4.3), simple assignment ($3.3.16.1), type
names ($3.5.5).


3.3.5 Multiplicative operators

Syntax

          multiplicative-expression:
                  cast-expression
                  multiplicative-expression *  cast-expression
                  multiplicative-expression /  cast-expression
                  multiplicative-expression %  cast-expression

Constraints

   Each of the operands shall have arithmetic type.  The operands of
the % operator shall have integral type.

Semantics

   The usual arithmetic conversions are performed on the operands.

   The result of the binary * operator is the product of the operands.

   The result of the / operator is the quotient from the division of
the first operand by the second; the result of the % operator is the
remainder.  In both operations, if the value of the second operand is
zero, the behavior is undefined.

   When integers are divided and the division is inexact, if both
operands are positive the result of the / operator is the largest
integer less than the algebraic quotient and the result of the %
operator is positive.  If either operand is negative, whether the
result of the / operator is the largest integer less than the
algebraic quotient or the smallest integer greater than the algebraic
quotient is implementation-defined, as is the sign of the result of
the % operator.  If the quotient a/b is representable, the expression
(a/b)*b + a%b shall equal a .


3.3.6 Additive operators

Syntax

          additive-expression:
                  multiplicative-expression
                  additive-expression +  multiplicative-expression
                  additive-expression -  multiplicative-expression

Constraints

   For addition, either both operands shall have arithmetic type, or
one operand shall be a pointer to an object type and the other shall
have integral type.  (Incrementing is equivalent to adding 1.)

   For subtraction, one of the following shall hold: 

 * both operands have arithmetic type; 

 * both operands are pointers to qualified or unqualified versions of
   compatible object types; or

 * the left operand is a pointer to an object type and the right
   operand has integral type.  (Decrementing is equivalent to subtracting 1.)

Semantics

   If both operands have arithmetic type, the usual arithmetic
conversions are performed on them.

   The result of the binary + operator is the sum of the operands.

   The result of the binary - operator is the difference resulting
from the subtraction of the second operand from the first.

   When an expression that has integral type is added to or subtracted
from a pointer, the integral value is first multiplied by the size of
the object pointed to.  The result has the type of the pointer
operand.  If the pointer operand points to a member of an array
object, and the array object is large enough, the result points to a
member of the same array object, appropriately offset from the
original member.  Thus if P points to a member of an array object, the
expression P+1 points to the next member of the array object.  Unless
both the pointer operand and the result point to a member of the same
array object, or one past the last member of the array object, the
behavior is undefined.  Unless both the pointer operand and the result
point to a member of the same array object, or the pointer operand
points one past the last member of an array object and the result
points to a member of the same array object, the behavior is undefined
if the result is used as the operand of a unary * operator.

   When two pointers to members of the same array object are
subtracted, the difference is divided by the size of a member.  The
result represents the difference of the subscripts of the two array
members.  The size of the result is implementation-defined, and its
type (a signed integral type) is ptrdiff_t defined in the <stddef.h>
header.  As with any other arithmetic overflow, if the result does not
fit in the space provided, the behavior is undefined.  If two pointers
that do not point to members of the same array object are subtracted,
the behavior is undefined.  However, if P points either to a member of
an array object or one past the last member of an array object, and Q
points to the last member of the same array object, the expression
(Q+1) - P has the same value as (Q-P) + 1 , even though Q+1 does not
point to a member of the array object.

Forward references: common definitions <stddef.h> ($4.1.5).  


3.3.7 Bitwise shift operators

Syntax

          shift-expression:
                  additive-expression
                  shift-expression <<  additive-expression
                  shift-expression >>  additive-expression

Constraints

   Each of the operands shall have integral type.  

Semantics

   The integral promotions are performed on each of the operands.  The
type of the result is that of the promoted left operand.  If the value
of the right operand is negative or is greater than or equal to the
width in bits of the promoted left operand, the behavior is undefined.

   The result of E1 << E2 is E1 left-shifted E2 bit positions; vacated
bits are filled with zeros.  If E1 has an unsigned type, the value of
the result is E1 multiplied by the quantity, 2 raised to the power E2,
reduced modulo ULONG_MAX+1 if E1 has type unsigned long, UINT_MAX+1
otherwise.  (The constants ULONG_MAX and UINT_MAX are defined in the
header <limits.h> .)

   The result of E1 >> E2 is E1 right-shifted E2 bit positions.  If E1
has an unsigned type or if E1 has a signed type and a nonnegative
value, the value of the result is the integral part of the quotient of
E1 divided by the quantity, 2 raised to the power E2 .  If E1 has a
signed type and a negative value, the resulting value is
implementation-defined.


3.3.8 Relational operators

Syntax

          relational-expression:
                  shift-expression
                  relational-expression <   shift-expression
                  relational-expression >   shift-expression
                  relational-expression <=  shift-expression
                  relational-expression >=  shift-expression

Constraints

   One of the following shall hold: 

 * both operands have arithmetic type; 

 * both operands are pointers to qualified or unqualified versions of
   compatible object types; or

 * both operands are pointers to qualified or unqualified versions of
   compatible incomplete types.

Semantics

   If both of the operands have arithmetic type, the usual arithmetic
conversions are performed.

   When two pointers are compared, the result depends on the relative
locations in the address space of the objects pointed to.  If the
objects pointed to are members of the same aggregate object, pointers
to structure members declared later compare higher than pointers to
members declared earlier in the structure, and pointers to array
elements with larger subscript values compare higher than pointers to
elements of the same array with lower subscript values.  All pointers
to members of the same union object compare equal.  If the objects
pointed to are not members of the same aggregate or union object, the
result is undefined, with the following exception.  If P points to the
last member of an array object and Q points to a member of the same
array object, the pointer expression P+1 compares higher than Q , even
though P+1 does not point to a member of the array object.

   Each of the operators < (less than), > (greater than), <= (less
than or equal to), and >= (greater than or equal to) shall yield 1 if
the specified relation is true and 0 if it is false./38/ The result
has type int.


3.3.9 Equality operators

Syntax

          equality-expression:
                  relational-expression
                  equality-expression ==  relational-expression
                  equality-expression !=  relational-expression

Constraints

   One of the following shall hold: 

 * both operands have arithmetic type; 

 * both operands are pointers to qualified or unqualified versions of
   compatible types;

 * one operand is a pointer to an object or incomplete type and the
   other is a qualified or unqualified version of void ; or

 * one operand is a pointer and the other is a null pointer constant.  

Semantics

   The == (equal to) and the != (not equal to) operators are analogous
to the relational operators except for their lower precedence./39/

   If two pointers to object or incomplete types compare equal, they
point to the same object.  If two pointers to functions compare equal,
they point to the same function.  If two pointers point to the same
object or function, they compare equal./40/ If one of the operands is
a pointer to an object or incomplete type and the other has type
pointer to a qualified or unqualified version of void , the pointer to
an object or incomplete type is converted to the type of the other
operand.


3.3.10 Bitwise AND operator

Syntax

          AND-expression:
                  equality-expression
                  AND-expression &  equality-expression

Constraints

   Each of the operands shall have integral type.  

Semantics

   The usual arithmetic conversions are performed on the operands.

   The result of the binary & operator is the bitwise AND of the
operands (that is, each bit in the result is set if and only if each
of the corresponding bits in the converted operands is set).


3.3.11 Bitwise exclusive OR operator

Syntax

          exclusive-OR-expression:
                  AND-expression
                  exclusive-OR-expression ^  AND-expression

Constraints

   Each of the operands shall have integral type.  

Semantics

   The usual arithmetic conversions are performed on the operands.

   The result of the ^ operator is the bitwise exclusive OR of the
operands (that is, each bit in the result is set if and only if
exactly one of the corresponding bits in the converted operands is
set).


3.3.12 Bitwise inclusive OR operator

Syntax

          inclusive-OR-expression:
                  exclusive-OR-expression
                  inclusive-OR-expression |  exclusive-OR-expression

Constraints

   Each of the operands shall have integral type.  

Semantics

   The usual arithmetic conversions are performed on the operands.

   The result of the | operator is the bitwise inclusive OR of the
operands (that is, each bit in the result is set if and only if at
least one of the corresponding bits in the converted operands is set).


3.3.13 Logical AND operator

Syntax

          logical-AND-expression:
                  inclusive-OR-expression
                  logical-AND-expression &&  inclusive-OR-expression

Constraints

   Each of the operands shall have scalar type.  

Semantics

   The && operator shall yield 1 if both of its operands compare
unequal to 0, otherwise it yields 0.  The result has type int.

   Unlike the bitwise binary & operator, the && operator guarantees
left-to-right evaluation; there is a sequence point after the
evaluation of the first operand.  If the first operand compares equal
to 0, the second operand is not evaluated.


3.3.14 Logical OR operator

Syntax

          logical-OR-expression:
                  logical-AND-expression
                  logical-OR-expression ||  logical-AND-expression

Constraints

   Each of the operands shall have scalar type.  

Semantics

   The || operator shall yield 1 if either of its operands compare
unequal to 0, otherwise it yields 0.  The result has type int.

   Unlike the bitwise | operator, the || operator guarantees
left-to-right evaluation; there is a sequence point after the
evaluation of the first operand.  If the first operand compares
unequal to 0, the second operand is not evaluated.


3.3.15 Conditional operator

Syntax

          conditional-expression:
                  logical-OR-expression
                  logical-OR-expression ?  expression :  conditional-expression

Constraints

   The first operand shall have scalar type.

   One of the following shall hold for the second and third operands: 

 * both operands have arithmetic type; 

 * both operands have compatible structure or union types; 

 * both operands have void type; 

 * both operands are pointers to qualified or unqualified versions of
   compatible types;

 * one operand is a pointer and the other is a null pointer constant; or 

 * one operand is a pointer to an object or incomplete type and the
   other is a pointer to a qualified or unqualified version of void .

Semantics

   The first operand is evaluated; there is a sequence point after its
evaluation.  The second operand is evaluated only if the first
compares unequal to 0; the third operand is evaluated only if the
first compares equal to 0; the value of the second or third operand
(whichever is evaluated) is the result./41/

   If both the second and third operands have arithmetic type, the
usual arithmetic conversions are performed to bring them to a common
type and the result has that type.  If both the operands have
structure or union type, the result has that type.  If both operands
have void type, the result has void type.

   If both the second and third operands are pointers or one is a null
pointer constant and the other is a pointer, the result type is a
pointer to a type qualified with all the type qualifiers of the types
pointed-to by both operands.  Furthermore, if both operands are
pointers to compatible types or differently qualified versions of a
compatible type, the result has the composite type; if one operand is
a null pointer constant, the result has the type of the other operand;
otherwise, one operand is a pointer to void or a qualified version of
void, in which case the other operand is converted to type pointer to
void, and the result has that type.


3.3.16 Assignment operators

Syntax

          assignment-expression:
                  conditional-expression
                  unary-expression assignment-operator assignment-expression

          assignment-operator: one of
                  =  *=  /=  %=  +=  -=  <<=  >>=  &=  ^=  |=

Constraints

   An assignment operator shall have a modifiable lvalue as its left operand.  

Semantics

   An assignment operator stores a value in the object designated by
the left operand.  An assignment expression has the value of the left
operand after the assignment, but is not an lvalue.  The type of an
assignment expression is the type of the left operand unless the left
operand has qualified type, in which case it is the unqualified
version of the type of the left operand.  The side effect of updating
the stored value of the left operand shall occur between the previous
and the next sequence point.

   The order of evaluation of the operands is unspecified.  


3.3.16.1 Simple assignment

Constraints

   One of the following shall hold:/42/ 

 * the left operand has qualified or unqualified arithmetic type and
   the right has arithmetic type;

 * the left operand has a qualified or unqualified version of a
   structure or union type compatible with the type of the right;

 * both operands are pointers to qualified or unqualified versions of
   compatible types, and the type pointed to by the left has all the
   qualifiers of the type pointed to by the right;

 * one operand is a pointer to an object or incomplete type and the
   other is a pointer to a qualified or unqualified version of void, and
   the type pointed to by the left has all the qualifiers of the type
   pointed to by the right; or

 * the left operand is a pointer and the right is a null pointer constant.  

Semantics

   In simple assignment ( = ), the value of the right operand is
   converted to the type of the assignment expression and replaces the
   value stored in the object designated by the left operand.

   If the value being stored in an object is accessed from another
   object that overlaps in any way the storage of the first object, then
   the overlap shall be exact and the two objects shall have qualified or
   unqualified versions of a compatible type; otherwise the behavior is
   undefined.

Example

   In the program fragment 

         int f(void);
         char c;
         /*...*/
         /*...*/ ((c = f()) == -1) /*...*/

the int value returned by the function may be truncated when stored in
the char, and then converted back to int width prior to the
comparison.  In an implementation in which ``plain'' char has the same
range of values as unsigned char (and char is narrower than int ), the
result of the conversion cannot be negative, so the operands of the
comparison can never compare equal.  Therefore, for full portability
the variable c should be declared as int.


3.3.16.2 Compound assignment

Constraints

   For the operators += and -= only, either the left operand shall be
a pointer to an object type and the right shall have integral type, or
the left operand shall have qualified or unqualified arithmetic type
and the right shall have arithmetic type.

   For the other operators, each operand shall have arithmetic type
consistent with those allowed by the corresponding binary operator.

Semantics

   A compound assignment of the form E1 op = E2 differs from the
simple assignment expression E1 = E1 op (E2) only in that the lvalue
E1 is evaluated only once.


3.3.17 Comma operator

Syntax

          expression:
                  assignment-expression
                  expression ,  assignment-expression

Semantics

   The left operand of a comma operator is evaluated as a void
expression; there is a sequence point after its evaluation.  Then the
right operand is evaluated; the result has its type and value./43/

Example

   As indicated by the syntax, in contexts where a comma is a
punctuator (in lists of arguments to functions and lists of
initializers) the comma operator as described in this section cannot
appear.  On the other hand, it can be used within a parenthesized
expression or within the second expression of a conditional operator
in such contexts.  In the function call

         f(a, (t=3, t+2), c)

the function has three arguments, the second of which has the value 5.  

Forward references: initialization ($3.5.7).  


3.4 CONSTANT EXPRESSIONS

Syntax

          constant-expression:
                  conditional-expression

Description

   A constant expression can be evaluated during translation rather
than runtime, and accordingly may be used in any place that a constant
may be.

Constraints

   Constant expressions shall not contain assignment, increment,
decrement, function-call, or comma operators, except when they are
contained within the operand of a sizeof operator./44/

   Each constant expression shall evaluate to a constant that is in
the range of representable values for its type.

Semantics

   An expression that evaluates to a constant is required in several
contexts./45/ If the expression is evaluated in the translation
environment, the arithmetic precision and range shall be at least as
great as if the expression were being evaluated in the execution
environment.

   An integral constant expression shall have integral type and shall
only have operands that are integer constants, enumeration constants,
character constants, sizeof expressions, and floating constants that
are the immediate operands of casts.  Cast operators in an integral
constant expression shall only convert arithmetic types to integral
types, except as part of an operand to the sizeof operator.

   More latitude is permitted for constant expressions in
initializers.  Such a constant expression shall evaluate to one of the
following:

 * an arithmetic constant expression, 

 * an address constant, or 

 * an address constant for an object type plus or minus an integral
   constant expression.

   An arithmetic constant expression shall have arithmetic type and
shall only have operands that are integer constants, floating
constants, enumeration constants, character constants, and sizeof
expressions.  Cast operators in an arithmetic constant expression
shall only convert arithmetic types to arithmetic types, except as
part of an operand to the sizeof operator.

   An address constant is a pointer to an lvalue designating an object
of static storage duration, or to a function designator; it shall be
created explicitly, using the unary & operator, or implicitly, by the
use of an expression of array or function type.  The array-subscript
[] and member-access .  and -> operators, the address & and
indirection * unary operators, and pointer casts may be used in the
creation an address constant, but the value of an object shall not be
accessed by use of these operators.

   The semantic rules for the evaluation of a constant expression are
the same as for non-constant expressions./46/

Forward references: initialization ($3.5.7).  


3.5 DECLARATIONS

Syntax

          declaration:
                  declaration-specifiers init-declarator-list<opt> ;

          declaration-specifiers:
                  storage-class-specifier declaration-specifiers<opt>
                  type-specifier declaration-specifiers<opt>
                  type-qualifier declaration-specifiers<opt>

          init-declarator-list:
                  init-declarator
                  init-declarator-list ,  init-declarator 

          init-declarator:
                  declarator
                  declarator =  initializer

Constraints

   A declaration shall declare at least a declarator, a tag, or the
members of an enumeration.

   If an identifier has no linkage, there shall be no more than one
declaration of the identifier (in a declarator or type specifier) with
the same scope and in the same name space, except for tags as
specified in $3.5.2.3.

   All declarations in the same scope that refer to the same object or
function shall specify compatible types.

Semantics

   A declaration specifies the interpretation and attributes of a set
of identifiers.  A declaration that also causes storage to be reserved
for an object or function named by an identifier is a definition ./47/

   The declaration specifiers consist of a sequence of specifiers that
indicate the linkage, storage duration, and part of the type of the
entities that the declarators denote.  The init-declarator-list is a
comma-separated sequence of declarators, each of which may have
additional type information, or an initializer, or both.  The
declarators contain the identifiers (if any) being declared.

   If an identifier for an object is declared with no linkage, the
type for the object shall be complete by the end of its declarator, or
by the end of its init-declarator if it has an initializer.

Forward references: declarators ($3.5.4), enumeration specifiers
($3.5.2.2), initialization ($3.5.7), tags ($3.5.2.3).


3.5.1 Storage-class specifiers

Syntax

          storage-class-specifier:
                  typedef
                  extern
                  static
                  auto
                  register

Constraints

   At most one storage-class specifier may be given in the declaration
specifiers in a declaration./48/

Semantics

   The typedef specifier is called a ``storage-class specifier'' for
syntactic convenience only; it is discussed in $3.5.6.  The meanings
of the various linkages and storage durations were discussed in
$3.1.2.2 and $3.1.2.4.

   A declaration of an identifier for an object with storage-class
specifier register suggests that access to the object be as fast as
possible.  The extent to which such suggestions are effective is
implementation-defined./49/

   The declaration of an identifier for a function that has block
scope shall have no explicit storage-class specifier other than extern.

Forward references: type definitions ($3.5.6).  


3.5.2 Type specifiers

Syntax

          type-specifier:
                  void
                  char
                  short
                  int
                  long
                  float
                  double
                  signed
                  unsigned
                   struct-or-union-specifier
                  enum-specifier
                  typedef-name

Constraints

Each list of type specifiers shall be one of the following sets; the
type specifiers may occur in any order, possibly intermixed with the
other declaration specifiers.

 * void 

 * char 

 * signed char 

 * unsigned char 

 * short , signed short , short int , or signed short int 

 * unsigned short , or unsigned short int 

 * int , signed , signed int , or no type specifiers 

 * unsigned , or unsigned int 

 * long , signed long , long int , or signed long int 

 * unsigned long , or unsigned long int 

 * float 

 * double 

 * long double 

 * struct-or-union specifier 

 * enum-specifier 

 * typedef-name 

Semantics

   Specifiers for structures, unions, and enumerations are discussed
in $3.5.2.1 through $3.5.2.3.  Declarations of typedef names are
discussed in $3.5.6.  The characteristics of the other types are
discussed in $3.1.2.5.

   Each of the above comma-separated lists designates the same type,
except that for bit-field declarations, signed int (or signed ) may
differ from int (or no type specifiers).

Forward references: enumeration specifiers ($3.5.2.2), structure and
union specifiers ($3.5.2.1), tags ($3.5.2.3), type definitions ($3.5.6).


3.5.2.1 Structure and union specifiers

Syntax

          struct-or-union-specifier:
                  struct-or-union identifier<opt> {  struct-declaration-list } 
                  struct-or-union identifier

          struct-or-union:
                  struct
                  union

          struct-declaration-list:
                  struct-declaration
                  struct-declaration-list struct-declaration

          struct-declaration:
                  specifier-qualifier-list struct-declarator-list ;

          specifier-qualifier-list:
                  type-specifier specifier-qualifier-list<opt>
                  type-qualifier specifier-qualifier-list<opt>

          struct-declarator-list:
                  struct-declarator
                  struct-declarator-list ,  struct-declarator

          struct-declarator:
                  declarator
                  declarator<opt> :  constant-expression

Constraints

   A structure or union shall not contain a member with incomplete or
function type.  Hence it shall not contain an instance of itself (but
may contain a pointer to an instance of itself).

   The expression that specifies the width of a bit-field shall be an
integral constant expression that has nonnegative value that shall not
exceed the number of bits in an ordinary object of compatible type.
If the value is zero, the declaration shall have no declarator.

Semantics

   As discussed in $3.1.2.5, a structure is a type consisting of a
sequence of named members, whose storage is allocated in an ordered
sequence, and a union is a type consisting of a sequence of named
members, whose storage overlap.

   Structure and union specifiers have the same form.

   The presence of a struct-declaration-list in a
struct-or-union-specifier declares a new type, within a translation
unit.  The struct-declaration-list is a sequence of declarations for
the members of the structure or union.  The type is incomplete until
after the } that terminates the list.

   A member of a structure or union may have any object type.  In
addition, a member may be declared to consist of a specified number of
bits (including a sign bit, if any).  Such a member is called a
bit-field ;/50/ its width is preceded by a colon.

   A bit-field may have type int , unsigned int , or signed int .
Whether the high-order bit position of a ``plain'' int bit-field is
treated as a sign bit is implementation-defined.  A bit-field is
interpreted as an integral type consisting of the specified number of
bits.

   An implementation may allocate any addressable storage unit large
enough to hold a bit-field.  If enough space remains, a bit-field that
immediately follows another bit-field in a structure shall be packed
into adjacent bits of the same unit.  If insufficient space remains,
whether a bit-field that does not fit is put into the next unit or
overlaps adjacent units is implementation-defined.  The order of
allocation of bit-fields within a unit (high-order to low-order or
low-order to high-order) is implementation-defined.  The alignment of
the addressable storage unit is unspecified.

   A bit-field declaration with no declarator, but only a colon and a
width, indicates an unnamed bit-field./51/ As a special case of this,
a bit-field with a width of 0 indicates that no further bit-field is
to be packed into the unit in which the previous bit-field, if any,
was placed.

   Each non-bit-field member of a structure or union object is aligned
in an implementation-defined manner appropriate to its type.

   Within a structure object, the non-bit-field members and the units
in which bit-fields reside have addresses that increase in the order
in which they are declared.  A pointer to a structure object, suitably
cast, points to its initial member (or if that member is a bit-field,
then to the unit in which it resides), and vice versa.  There may
therefore be unnamed holes within a structure object, but not at its
beginning, as necessary to achieve the appropriate alignment.

   The size of a union is sufficient to contain the largest of its
members.  The value of at most one of the members can be stored in a
union object at any time.  A pointer to a union object, suitably cast,
points to each of its members (or if a member is a bit-field, then to
the unit in which it resides), and vice versa.

   There may also be unnamed padding at the end of a structure or
union, as necessary to achieve the appropriate alignment were the
structure or union to be a member of an array.


3.5.2.2 Enumeration specifiers

Syntax

          enum-specifier:
                  enum  identifier<opt> { enumerator-list }
                  enum  identifier

          enumerator-list:
                  enumerator
                  enumerator-list , enumerator

          enumerator:
                  enumeration-constant
                  enumeration-constant = constant-expression

Constraints

   The expression that defines the value of an enumeration constant
shall be an integral constant expression that has a value
representable as an int.

Semantics

   The identifiers in an enumerator list are declared as constants
that have type int and may appear wherever such are permitted./52/ An
enumerator with = defines its enumeration constant as the value of the
constant expression.  If the first enumerator has no = , the value of
its enumeration constant is 0.  Each subsequent enumerator with no =
defines its enumeration constant as the value of the constant
expression obtained by adding 1 to the value of the previous
enumeration constant.  (A combination of both forms of enumerators may
produce enumeration constants with values that duplicate other values
in the same enumeration.) The enumerators of an enumeration are also
known as its members.

   Each enumerated type shall be compatible with an integer type; the
choice of type is implementation-defined.

Example

         enum hue { chartreuse, burgundy, claret=20, winedark };
         /*...*/
         enum hue col, *cp;
         /*...*/
         col = claret;
         cp = &col;
         /*...*/
         /*...*/ (*cp != burgundy) /*...*/

makes hue the tag of an enumeration, and then declares col as an
object that has that type and cp as a pointer to an object that has
that type.  The enumerated values are in the set {0, 1, 20, 21}.


3.5.2.3 Tags

   A type specifier of the form 

          struct-or-union identifier {  struct-declaration-list }
         enum  identifier {  enumerator-list }

declares the identifier to be the tag of the structure, union, or
enumeration specified by the list.  The list defines the structure
content ,union content ,or enumeration content .If this declaration of
the tag is visible, a subsequent declaration that uses the tag and
that omits the bracketed list specifies the declared structure, union,
or enumerated type.  Subsequent declarations in the same scope shall
omit the bracketed list.

   If a type specifier of the form 

          struct-or-union identifier

occurs prior to the declaration that defines the content, the
structure or union is an incomplete type./53/ It declares a tag that
specifies a type that may be used only when the size of an object of
the specified type is not needed./54/ If the type is to be completed,
another declaration of the tag in the same scope (but not in an
enclosed block, which declares a new type known only within that
block) shall define the content.  A declaration of the form

          struct-or-union identifier ;

specifies a structure or union type and declares a tag, both visible
only within the scope in which the declaration occurs.  It specifies a
new type distinct from any type with the same tag in an enclosing
scope (if any).

   A type specifier of the form 

          struct-or-union {  struct-declaration-list }
         enum {  enumerator-list }

specifies a new structure, union, or enumerated type, within the
translation unit, that can only be referred to by the declaration of
which it is a part./55/

Examples

   This mechanism allows declaration of a self-referential structure.  

         struct tnode {
                  int count;
                  struct tnode *left, *right;
         };

specifies a structure that contains an integer and two pointers to
objects of the same type.  Once this declaration has been given, the
declaration

         struct tnode s, *sp;

declares s to be an object of the given type and sp to be a pointer to
an object of the given type.  With these declarations, the expression
sp->left refers to the left struct tnode pointer of the object to
which sp points; the expression s.right->count designates the count
member of the right struct tnode pointed to from s .

   The following alternative formulation uses the typedef mechanism: 

         typedef struct tnode TNODE;
         struct tnode {
                  int count;
                  TNODE *left, *right;
         };
         TNODE s, *sp;

   To illustrate the use of prior declaration of a tag to specify a
pair of mutually-referential structures, the declarations

         struct s1 { struct s2 *s2p; /*...*/ }; /* D1 */
         struct s2 { struct s1 *s1p; /*...*/ }; /* D2 */

specify a pair of structures that contain pointers to each other.
Note, however, that if s2 were already declared as a tag in an
enclosing scope, the declaration D1 would refer to it, not to the tag
s2 declared in D2 .  To eliminate this context sensitivity, the
otherwise vacuous declaration

         struct s2;

may be inserted ahead of D1.  This declares a new tag s2 in the inner
scope; the declaration D2 then completes the specification of the new type.

Forward references: type definitions ($3.5.6).  


3.5.3 Type qualifiers

Syntax

          type-qualifier:
                  const
                  volatile

Constraints

   The same type qualifier shall not appear more than once in the same
specifier list or qualifier list, either directly or via one or more
typedef s.

Semantics

   The properties associated with qualified types are meaningful only
for expressions that are lvalues./56/

   If an attempt is made to modify an object defined with a
const-qualified type through use of an lvalue with non-const-qualified
type, the behavior is undefined.  If an attempt is made to refer to an
object defined with a volatile-qualified type through use of an lvalue
with non-volatile-qualified type, the behavior is undefined./57/

   An object that has volatile-qualified type may be modified in ways
unknown to the implementation or have other unknown side effects.
Therefore any expression referring to such an object shall be
evaluated strictly according to the rules of the abstract machine, as
described in $2.1.2.3.  Furthermore, at every sequence point the value
last stored in the object shall agree with that prescribed by the
abstract machine, except as modified by the unknown factors mentioned
previously./58/ What constitutes an access to an object that has
volatile-qualified type is implementation-defined.

   If the specification of an array type includes any type qualifiers,
the element type is so-qualified, not the array type.  If the
specification of a function type includes any type qualifiers, the
behavior is undefined./59/

   For two qualified types to be compatible, both shall have the
identically qualified version of a compatible type; the order of type
qualifiers within a list of specifiers or qualifiers does not affect
the specified type.

Examples

   An object declared 

         extern const volatile int real_time_clock;

may be modifiable by hardware, but cannot be assigned to, incremented,
or decremented.

   The following declarations and expressions illustrate the behavior
when type qualifiers modify an aggregate type:

         const struct s { int mem; } cs = { 1 };
         struct s ncs;  /*  the object ncs  is modifiable */
         typedef int A[2][3];
         const A a = {{4, 5, 6}, {7, 8, 9}}; /* array of array of const  int */
         int *pi;
         const int *pci;

         ncs = cs;      /*  valid */
         cs = ncs;      /*  violates modifiable lvalue constraint for = */
         pi = &ncs.mem; /*  valid */
         pi = &cs.mem;  /*  violates type constraints for = */
         pci = &cs.mem; /*  valid */
         pi = a[0];     /*  invalid: a[0]  has type ``const int * '' */


3.5.4 Declarators

Syntax

          declarator:
                  pointer<opt> direct-declarator

          direct-declarator:
                  identifier
                  (  declarator ) 
                  direct-declarator [  constant-expression<opt> ] 

                  direct-declarator (  parameter-type-list ) 
                  direct-declarator (  identifier-list<opt> )

          pointer:
                  *  type-qualifier-list<opt>
                  *  type-qualifier-list<opt> pointer

          type-qualifier-list:
                  type-qualifier
                  type-qualifier-list type-qualifier

          parameter-type-list:
                  parameter-list
                  parameter-list , ...

          parameter-list:
                  parameter-declaration
                  parameter-list ,  parameter-declaration

          parameter-declaration:
                  declaration-specifiers declarator
                  declaration-specifiers abstract-declarator<opt>

          identifier-list:
                  identifier
                  identifier-list ,  identifier

Semantics

   Each declarator declares one identifier, and asserts that when an
operand of the same form as the declarator appears in an expression,
it designates a function or object with the scope, storage duration,
and type indicated by the declaration specifiers.

   In the following subsections, consider a declaration 

         T D1

where T contains the declaration specifiers that specify a type T
(such as int) and D1 is a declarator that contains an identifier
ident . The type specified for the identifier ident in the various
forms of declarator is described inductively using this notation.

   If, in the declaration `` T D1 ,'' D1 has the form 

          identifier

then the type specified for ident is T .

   If, in the declaration `` T D1 ,'' D1 has the form 

         ( D )

then ident has the type specified by the declaration `` T D .'' Thus,
a declarator in parentheses is identical to the unparenthesized
declarator, but the binding of complex declarators may be altered by
parentheses.

"Implementation limits"

   The implementation shall allow the specification of types that have
at least 12 pointer, array, and function declarators (in any valid
combinations) modifying an arithmetic, a structure, a union, or an
incomplete type, either directly or via one or more typedef s.

Forward references: type definitions ($3.5.6).  


3.5.4.1 Pointer declarators

Semantics

   If, in the declaration `` T D1 ,'' D1 has the form 

         *  type-qualifier-list<opt> D

and the type specified for ident in the declaration `` T D '' is ``
"derived-declarator-type-list T" ,'' then the type specified for ident
is `` "derived-declarator-type-list type-qualifier-list" pointer to T.''
For each type qualifier in the list, ident is a so-qualified pointer.

   For two pointer types to be compatible, both shall be identically
qualified and both shall be pointers to compatible types.

Examples

   The following pair of declarations demonstrates the difference
between a ``variable pointer to a constant value'' and a ``constant
pointer to a variable value.''

         const int *ptr_to_constant;
         int *const constant_ptr;

The contents of the const int pointed to by ptr_to_constant shall not
be modified, but ptr_to_constant itself may be changed to point to
another const int .  Similarly, the contents of the int pointed to by
constant_ptr may be modified, but constant_ptr itself shall always
point to the same location.

   The declaration of the constant pointer constant_ptr may be
clarified by including a definition for the type ``pointer to int .''

         typedef int *int_ptr;
         const int_ptr constant_ptr;

declares constant_ptr as an object that has type ``const-qualified
pointer to int .''


3.5.4.2 Array declarators

Constraints

   The expression that specifies the size of an array shall be an
integral constant expression that has a value greater than zero.

Semantics

   If, in the declaration `` T D1 ,'' D1 has the form 

         D[ constant-expression<opt>]

and the type specified for ident in the declaration `` T D '' is ``
"derived-declarator-type-list T" ,'' then the type specified for ident
is `` derived-declarator-type-list array of T .''/60/ If the size is
not present, the array type is an incomplete type.

   For two array types to be compatible, both shall have compatible
element types, and if both size specifiers are present, they shall
have the same value.

Examples

         float fa[11], *afp[17];

declares an array of float numbers and an array of pointers to float
numbers.

   Note the distinction between the declarations 

         extern int *x;
         extern int y[];

The first declares x to be a pointer to int ; the second declares y to
be an array of int of unspecified size (an incomplete type), the
storage for which is defined elsewhere.

Forward references: function definitions ($3.7.1), initialization ($3.5.7).  


3.5.4.3 Function declarators (including prototypes)

Constraints

   A function declarator shall not specify a return type that is a
function type or an array type.

   The only storage-class specifier that shall occur in a parameter
declaration is register.

   An identifier list in a function declarator that is not part of a
function definition shall be empty.

Semantics

   If, in the declaration `` T D1 ,'' D1 has the form 

         D( parameter-type-list)
         D( identifier-list<opt>)

and the type specified for ident in the declaration `` T D '' is ``
"derived-declarator-type-list T" ,'' then the type specified for ident
is `` derived-declarator-type-list function returning T .''

   A parameter type list specifies the types of, and may declare
identifiers for, the parameters of the function.  If the list
terminates with an ellipsis ( , ... ), no information about the number
or types of the parameters after the comma is supplied./61/ The
special case of void as the only item in the list specifies that the
function has no parameters.

   In a parameter declaration, a single typedef name in parentheses is
taken to be an abstract declarator that specifies a function with a
single parameter, not as redundant parentheses around the identifier
for a declarator.

   The storage-class specifier in the declaration specifiers for a
parameter declaration, if present, is ignored unless the declared
parameter is one of the members of the parameter type list for a
function definition.

   An identifier list declares only the identifiers of the parameters
of the function.  An empty list in a function declarator that is part
of a function definition specifies that the function has no
parameters.  The empty list in a function declarator that is not part
of a function definition specifies that no information about the
number or types of the parameters is supplied./62/

   For two function types to be compatible, both shall specify
compatible return types./63/ Moreover, the parameter type lists, if
both are present, shall agree in the number of parameters and in use
of the ellipsis terminator; corresponding parameters shall have
compatible types.  If one type has a parameter type list and the other
type is specified by a function declarator that is not part of a
function definition and that contains an empty identifier list, the
parameter list shall not have an ellipsis terminator and the type of
each parameter shall be compatible with the type that results from the
application of the default argument promotions.  If one type has a
parameter type list and the other type is specified by a function
definition that contains a (possibly empty) identifier list, both
shall agree in the number of parameters, and the type of each
prototype parameter shall be compatible with the type that results
from the application of the default argument promotions to the type of
the corresponding identifier.  (For each parameter declared with
function or array type, its type for these comparisons is the one that
results from conversion to a pointer type, as in $3.7.1.  For each
parameter declared with qualified type, its type for these comparisons
is the unqualified version of its declared type.)

Examples

   The declaration 

         int f(void), *fip(), (*pfi)();

declares a function f with no parameters returning an int , a function
fip with no parameter specification returning a pointer to an int ,
and a pointer pfi to a function with no parameter specification
returning an int .  It is especially useful to compare the last two.
The binding of *fip() is *(fip()) , so that the declaration suggests,
and the same construction in an expression requires, the calling of a
function fip , and then using indirection through the pointer result
to yield an int .  In the declarator (*pfi)() , the extra parentheses
are necessary to indicate that indirection through a pointer to a
function yields a function designator, which is then used to call the
function; it returns an int.

   If the declaration occurs outside of any function, the identifiers
have file scope and external linkage.  If the declaration occurs
inside a function, the identifiers of the functions f and fip have
block scope and external linkage, and the identifier of the pointer
pfi has block scope and no linkage.

   Here are two more intricate examples.  

         int (*apfi[3])(int *x, int *y);

declares an array apfi of three pointers to functions returning int .
Each of these functions has two parameters that are pointers to int .
The identifiers x and y are declared for descriptive purposes only and
go out of scope at the end of the declaration of apfi .  The
declaration

         int (*fpfi(int (*)(long), int))(int, ...);

declares a function fpfi that returns a pointer to a function
returning an int.  The function fpfi has two parameters: a pointer to
a function returning an int (with one parameter of type long ), and an
int .  The pointer returned by fpfi points to a function that has at
least one parameter, which has type int .

Forward references: function definitions ($3.7.1), type names ($3.5.5).  


3.5.5 Type names

Syntax

          type-name:
                  specifier-qualifier-list abstract-declarator<opt>

          abstract-declarator:
                  pointer
                  pointer<opt> direct-abstract-declarator

          direct-abstract-declarator:
                  (  abstract-declarator ) 
                  direct-abstract-declarator<opt> [  constant-expression<opt> ] 
                  direct-abstract-declarator<opt> (  parameter-type-list<opt> )

Semantics

   In several contexts it is desired to specify a type.  This is
accomplished using a type name, which is syntactically a declaration
for a function or an object of that type that omits the
identifier./64/

Examples

   The constructions 

         (a)      int
         (b)      int *
         (c)      int *[3]
         (d)      int (*)[3]
         (e)      int *()
         (f)      int (*)(void)
         (g)      int (*const [])(unsigned int, ...)

name respectively the types (a) int , (b) pointer to int , (c) array
of three pointers to int , (d) pointer to an array of three int's, (e)
function with no parameter specification returning a pointer to int ,
(f) pointer to function with no parameters returning an int , and (g)
array of an unspecified number of constant pointers to functions, each
with one parameter that has type unsigned int and an unspecified
number of other parameters, returning an int .


3.5.6 Type definitions

Syntax

          typedef-name:
                  identifier

Semantics

   In a declaration whose storage-class specifier is typedef , each
declarator defines an identifier to be a typedef name that specifies
the type specified for the identifier in the way described in $3.5.4.
A typedef declaration does not introduce a new type, only a synonym
for the type so specified.  That is, in the following declarations:

         typedef T type_ident;
         type_ident D;

type_ident is defined as a typedef name with the type specified by the
declaration specifiers in T (known as T ), and the identifier in D has
the type `` "derived-declarator-type-list T" '' where the
derived-declarator-type-list is specified by the declarators of D .  A
typedef name shares the same name space as other identifiers declared
in ordinary declarators.  If the identifier is redeclared in an inner
scope or is declared as a member of a structure or union in the same
or an inner scope, the type specifiers shall not be omitted in the
inner declaration.

Examples

   After 

         typedef int MILES, KLICKSP();
         typedef struct { double re, im; } complex;

the constructions 

         MILES distance;
         extern KLICKSP *metricp;
         complex x;
         complex z, *zp;

are all valid declarations.  The type of distance is int , that of
metricp is ``pointer to function with no parameter specification
returning int ,'' and that of x and z is the specified structure; zp
is a pointer to such a structure.  The object distance has a type
compatible with any other int object.

   After the declarations 

         typedef struct s1 { int x; } t1, *tp1;
         typedef struct s2 { int x; } t2, *tp2;

type t1 and the type pointed to by tp1 are compatible.  Type t1 is
also compatible with type struct s1 , but not compatible with the
types struct s2 , t2 , the type pointed to by tp2 , and int .

   The following constructions 

         typedef signed int t;
         typedef int plain;
         struct tag {
                  unsigned t:4;
                  const t:5;
                  plain r:5;
         };

declare a typedef name t with type signed int , a typedef name plain
with type int , and a structure with three bit-field members, one
named t that contains values in the range [0,15], an unnamed
const-qualified bit-field which (if it could be accessed) would
contain values in at least the range [-15,+15], and one named r that
contains values in the range [0,31] or values in at least the range
[-15,+15].  (The choice of range is implementation-defined.) If these
declarations are followed in an inner scope by

         t f(t (t));
         long t;

then a function f is declared with type ``function returning signed
int with one unnamed parameter with type pointer to function returning
signed int with one unnamed parameter with type signed int ,'' and an
identifier t with type long .


3.5.7 Initialization

Syntax

          initializer:
                  assignment-expression
                  {  initializer-list } 
                  {  initializer-list , }

          initializer-list:
                  initializer
                  initializer-list ,  initializer

Constraints

   There shall be no more initializers in an initializer list than
there are objects to be initialized.

   The type of the entity to be initialized shall be an object type or
an array of unknown size.

   All the expressions in an initializer for an object that has static
storage duration or in an initializer list for an object that has
aggregate or union type shall be constant expressions.

   If the declaration of an identifier has block scope, and the
identifier has external or internal linkage, there shall be no
initializer for the identifier.

Semantics

   An initializer specifies the initial value stored in an object.

   All unnamed structure or union members are ignored during initialization.

   If an object that has static storage duration is not initialized
explicitly, it is initialized implicitly as if every member that has
arithmetic type were assigned 0 and every member that has pointer type
were assigned a null pointer constant.  If an object that has
automatic storage duration is not initialized explicitly, its value is
indeterminate./65/

   The initializer for a scalar shall be a single expression,
optionally enclosed in braces.  The initial value of the object is
that of the expression; the same type constraints and conversions as
for simple assignment apply.

   A brace-enclosed initializer for a union object initializes the
member that appears first in the declaration list of the union type.

   The initializer for a structure or union object that has automatic
storage duration either shall be an initializer list as described
below, or shall be a single expression that has compatible structure
or union type.  In the latter case, the initial value of the object is
that of the expression.

   The rest of this section deals with initializers for objects that
have aggregate or union type.

   An array of character type may be initialized by a character string
literal, optionally enclosed in braces.  Successive characters of the
character string literal (including the terminating null character if
there is room or if the array is of unknown size) initialize the
members of the array.

   An array with element type compatible with wchar_t may be
initialized by a wide string literal, optionally enclosed in braces.
Successive codes of the wide string literal (including the terminating
zero-valued code if there is room or if the array is of unknown size)
initialize the members of the array.

   Otherwise, the initializer for an object that has aggregate type
shall be a brace-enclosed list of initializers for the members of the
aggregate, written in increasing subscript or member order; and the
initializer for an object that has union type shall be a
brace-enclosed initializer for the first member of the union.

   If the aggregate contains members that are aggregates or unions, or
if the first member of a union is an aggregate or union, the rules
apply recursively to the subaggregates or contained unions.  If the
initializer of a subaggregate or contained union begins with a left
brace, the initializers enclosed by that brace and its matching right
brace initialize the members of the subaggregate or the first member
of the contained union.  Otherwise, only enough initializers from the
list are taken to account for the members of the first subaggregate or
the first member of the contained union; any remaining initializers
are left to initialize the next member of the aggregate of which the
current subaggregate or contained union is a part.

   If there are fewer initializers in a list than there are members of
an aggregate, the remainder of the aggregate shall be initialized
implicitly the same as objects that have static storage duration.

   If an array of unknown size is initialized, its size is determined
by the number of initializers provided for its members.  At the end of
its initializer list, the array no longer has incomplete type.

Examples

   The declaration 

         int x[] = { 1, 3, 5 };

defines and initializes x as a one-dimensional array object that has
three members, as no size was specified and there are three
initializers.

         float y[4][3] = {
                  { 1, 3, 5 },
                  { 2, 4, 6 },
                  { 3, 5, 7 },
         };

is a definition with a fully bracketed initialization: 1, 3, and 5
initialize the first row of the array object y[0] , namely y[0][0] ,
y[0][1] , and y[0][2] .  Likewise the next two lines initialize y[1]
and y[2] .  The initializer ends early, so y[3] is initialized with
zeros.  Precisely the same effect could have been achieved by

         float y[4][3] = {
                  1, 3, 5, 2, 4, 6, 3, 5, 7
         };

The initializer for y[0] does not begin with a left brace, so three
items from the list are used.  Likewise the next three are taken
successively for y[1] and y[2] .  Also,

         float z[4][3] = {
                  { 1 }, { 2 }, { 3 }, { 4 }
         };

initializes the first column of z as specified and initializes the
rest with zeros.
   
         struct { int a[3], b; } w[] = { { 1 }, 2 };

is a definition with an inconsistently bracketed initialization.  It
defines an array with two member structures: w[0].a[0] is 1 and
w[1].a[0] is 2; all the other elements are zero.

   The declaration 

         short q[4][3][2] = {
                  { 1 },
                  { 2, 3 },
                  { 4, 5, 6 }
         };

contains an incompletely but consistently bracketed initialization.
It defines a three-dimensional array object: q[0][0][0] is 1,
q[1][0][0] is 2, q[1][0][1] is 3, and 4, 5, and 6 initialize
q[2][0][0] , q[2][0][1] , and q[2][1][0] , respectively; all the rest
are zero.  The initializer for q[0][0][0] does not begin with a left
brace, so up to six items from the current list may be used.  There is
only one, so the values for the remaining five members are initialized
with zero.  Likewise, the initializers for q[1][0][0] and q[2][0][0]
do not begin with a left brace, so each uses up to six items,
initializing their respective two-dimensional subaggregates.  If there
had been more than six items in any of the lists, a diagnostic message
would occur.  The same initialization result could have been achieved
by:

         short q[4][3][2] = {
                  1, 0, 0, 0, 0, 0,
                  2, 3, 0, 0, 0, 0,
                  4, 5, 6
         };

or by: 

         short q[4][3][2] = {
                  {
                           { 1 },
                  },
                  {
                           { 2, 3 },
                  },
                  {
                           { 4, 5 },
                           { 6 },
                  }
         };

in a fully-bracketed form.

   Note that the fully-bracketed and minimally-bracketed forms of
initialization are, in general, less likely to cause confusion.

   Finally, the declaration 

         char s[] = "abc", t[3] = "abc";

defines ``plain'' char array objects s and t whose members are
initialized with character string literals.  This declaration is
identical to

         char s[] = { 'a', 'b', 'c', '\0' },
              t[] = { 'a', 'b', 'c' };

The contents of the arrays are modifiable.  On the other hand, the
declaration

         char *p = "abc";

defines p with type ``pointer to char '' that is initialized to point
to an object with type ``array of char '' whose members are
initialized with a character string literal.  If an attempt is made to
use p to modify the contents of the array, the behavior is undefined.

Forward references: common definitions <stddef.h> ($4.1.5).  


3.6 STATEMENTS

Syntax

          statement:
                  labeled-statement
                  compound-statement
                  expression-statement
                  selection-statement
                  iteration-statement
                  jump-statement

Semantics

   A statement specifies an action to be performed.  Except as
indicated, statements are executed in sequence.

   A full expression is an expression that is not part of another
expression.  Each of the following is a full expression: an
initializer; the expression in an expression statement; the
controlling expression of a selection statement ( if or switch ); the
controlling expression of a while or do statement; each of the three
expressions of a for statement; the expression in a return statement.
The end of a full expression is a sequence point.

Forward references: expression and null statements ($3.6.3), selection
statements ($3.6.4), iteration statements ($3.6.5), the return
statement ($3.6.6.4).


3.6.1 Labeled statements

Syntax

          labeled-statement:
                  identifier :  statement
                  case  constant-expression :  statement
                  default :  statement

Constraints

   A case or default label shall appear only in a switch statement.
Further constraints on such labels are discussed under the switch
statement.

Semantics

   Any statement may be preceded by a prefix that declares an
identifier as a label name.  Labels in themselves do not alter the
flow of control, which continues unimpeded across them.

Forward references: the goto statement ($3.6.6.1), the switch
statement ($3.6.4.2).


3.6.2 Compound statement, or block

Syntax

          compound-statement:
                  {  declaration-list<opt> statement-list<opt> }

          declaration-list:
                  declaration
                  declaration-list declaration

          statement-list:
                  statement
                  statement-list statement

Semantics

   A compound statement (also called a block )allows a set of
statements to be grouped into one syntactic unit, which may have its
own set of declarations and initializations (as discussed in
$3.1.2.4).  The initializers of objects that have automatic storage
duration are evaluated and the values are stored in the objects in the
order their declarators appear in the translation unit.


3.6.3 Expression and null statements

Syntax

          expression-statement:
                  expression<opt> ;

Semantics

   The expression in an expression statement is evaluated as a void
expression for its side effects./66/

   A null statement (consisting of just a semicolon) performs no
operations.

Examples

   If a function call is evaluated as an expression statement for its
side effects only, the discarding of its value may be made explicit by
converting the expression to a void expression by means of a cast:

         int p(int);
         /*...*/
         (void)p(0);


   In the program fragment 

         char *s;
         /*...*/
         while (*s++ != '\0')
                  ;

a null statement is used to supply an empty loop body to the iteration
statement.

   A null statement may also be used to carry a label just before the
closing } of a compound statement.

         while (loop1) {
                  /*...*/
                  while (loop2) {
                           /*...*/
                           if (want_out)
                                    goto end_loop1;
                           /*...*/
                  }
                  /*...*/
         end_loop1: ;
         }



Forward references: iteration statements ($3.6.5).  


3.6.4 Selection statements

Syntax

          selection-statement:
                  if (  expression )  statement
                  if (  expression )  statement else  statement
                  switch (  expression )  statement

Semantics

   A selection statement selects among a set of statements depending
on the value of a controlling expression.


3.6.4.1 The if statement

Constraints

   The controlling expression of an if statement shall have scalar type.  

Semantics

   In both forms, the first substatement is executed if the expression
compares unequal to 0.  In the else form, the second substatement is
executed if the expression compares equal to 0.  If the first
substatement is reached via a label, the second substatement is not
executed.

   An else is associated with the lexically immediately preceding else
-less if that is in the same block (but not in an enclosed block).


3.6.4.2 The switch statement

Constraints

   The controlling expression of a switch statement shall have
integral type.  The expression of each case label shall be an integral
constant expression.  No two of the case constant expressions in the
same switch statement shall have the same value after conversion.
There may be at most one default label in a switch statement.  (Any
enclosed switch statement may have a default label or case constant
expressions with values that duplicate case constant expressions in
the enclosing switch statement.)

Semantics

   A switch statement causes control to jump to, into, or past the
statement that is the switch body, depending on the value of a
controlling expression, and on the presence of a default label and the
values of any case labels on or in the switch body.  A case or default
label is accessible only within the closest enclosing switch
statement.

   The integral promotions are performed on the controlling
expression.  The constant expression in each case label is converted
to the promoted type of the controlling expression.  If a converted
value matches that of the promoted controlling expression, control
jumps to the statement following the matched case label.  Otherwise,
if there is a default label, control jumps to the labeled statement.
If no converted case constant expression matches and there is no
default label, no part of the switch body is executed.

"Implementation limits"

   As discussed previously ($2.2.4.1), the implementation may limit
the number of case values in a switch statement.


3.6.5 Iteration statements

Syntax

          iteration-statement:
                  while (  expression )  statement
                  do  statement while (  expression ) ;
                  for ( expression<opt> ; expression<opt> ;
                      expression<opt> ) statement

Constraints

   The controlling expression of an iteration statement shall have scalar type.  
Semantics

   An iteration statement causes a statement called the loop body to
be executed repeatedly until the controlling expression compares equal
to 0.


3.6.5.1 The while statement

   The evaluation of the controlling expression takes place before
each execution of the loop body.


3.6.5.2 The do statement

   The evaluation of the controlling expression takes place after each
execution of the loop body.


3.6.5.3 The for statement

   Except for the behavior of a continue statement in the loop body,
the statement

         for (  expression-1 ;  expression-2 ;  expression-3 )  statement

and the sequence of statements 

          expression-1 ;
         while ( expression-2) {
                   statement
                  expression-3 ;
         }

are equivalent./67/ expression-1 expression-2 , expression-3

   Both expression-1 and expression-3 may be omitted.  Each is
evaluated as a void expression.  An omitted expression-2 is replaced
by a nonzero constant.

Forward references: the continue statement ($3.6.6.2).  


3.6.6 Jump statements

Syntax

          jump-statement:
                  goto  identifier ;
                  continue ;
                  break ;
                  return  expression<opt> ;

Semantics

   A jump statement causes an unconditional jump to another place.  


3.6.6.1 The goto statement

Constraints

   The identifier in a goto statement shall name a label located
somewhere in the current function.

Semantics

   A goto statement causes an unconditional jump to the statement
prefixed by the named label in the current function.


3.6.6.2 The continue statement

Constraints

   A continue statement shall appear only in or as a loop body.  

Semantics

   A continue statement causes a jump to the loop-continuation portion
of the smallest enclosing iteration statement; that is, to the end of
the loop body.  More precisely, in each of the statements

         while (/*...*/) {    do {                 for (/*...*/) {
           /*...*/              /*...*/              /*...*/
           continue;            continue;            continue;
           /*...*/              /*...*/              /*...*/
         contin: ;            contin: ;            contin: ;
         }                    } while (/*...*/);   }

unless the continue statement shown is in an enclosed iteration
statement (in which case it is interpreted within that statement), it
is equivalent to goto contin; ./68/


3.6.6.3 The break statement

Constraints

   A break statement shall appear only in or as a switch body or loop body.  

Semantics

   A break statement terminates execution of the smallest enclosing
switch or iteration statement.


3.6.6.4 The return statement

Constraints

   A return statement with an expression shall not appear in a
function whose return type is void .

Semantics

   A return statement terminates execution of the current function and
returns control to its caller.  A function may have any number of
return statements, with and without expressions.

   If a return statement with an expression is executed, the value of
the expression is returned to the caller as the value of the function
call expression.  If the expression has a type different from that of
the function in which it appears, it is converted as if it were
assigned to an object of that type.

   If a return statement without an expression is executed, and the
value of the function call is used by the caller, the behavior is
undefined.  Reaching the } that terminates a function is equivalent to
executing a return statement without an expression.


3.7 EXTERNAL DEFINITIONS

Syntax

          translation-unit:
                  external-declaration
                  translation-unit external-declaration

          external-declaration:
                  function-definition
                  declaration

Constraints

   The storage-class specifiers auto and register shall not appear in
the declaration specifiers in an external declaration.

   There shall be no more than one external definition for each
identifier declared with internal linkage in a translation unit.
Moreover, if an identifier declared with internal linkage is used in
an expression (other than as a part of the operand of a sizeof
operator), there shall be exactly one external definition for the
identifier in the translation unit.

Semantics

   As discussed in $2.1.1.1, the unit of program text after
preprocessing is a translation unit, which consists of a sequence of
external declarations.  These are described as ``external'' because
they appear outside any function (and hence have file scope).  As
discussed in $3.5, a declaration that also causes storage to be
reserved for an object or a function named by the identifier is a
definition.

   An external definition is an external declaration that is also a
definition of a function or an object.  If an identifier declared with
external linkage is used in an expression (other than as part of the
operand of a sizeof operator), somewhere in the entire program there
shall be exactly one external definition for the identifier./69/


3.7.1 Function definitions

Syntax

          function-definition:
                  declaration-specifiers<opt> declarator
                            declaration-list<opt> compound-statement

Constraints

   The identifier declared in a function definition (which is the name
of the function) shall have a function type, as specified by the
declarator portion of the function definition./70/

   The return type of a function shall be void or an object type other
than array.

   The storage-class specifier, if any, in the declaration specifiers
shall be either extern or static .

   If the declarator includes a parameter type list, the declaration
of each parameter shall include an identifier (except for the special
case of a parameter list consisting of a single parameter of type void,
in which there shall not be an identifier).  No declaration list
shall follow.

   If the declarator includes an identifier list, only the identifiers
it names shall be declared in the declaration list.  An identifier
declared as a typedef name shall not be redeclared as a parameter.
The declarations in the declaration list shall contain no
storage-class specifier other than register and no initializations.

Semantics

   The declarator in a function definition specifies the name of the
function being defined and the identifiers of its parameters.  If the
declarator includes a parameter type list, the list also specifies the
types of all the parameters; such a declarator also serves as a
function prototype for later calls to the same function in the same
translation unit.  If the declarator includes an identifier list,/71/
the types of the parameters may be declared in a following declaration
list.  Any parameter that is not declared has type int .

   If a function that accepts a variable number of arguments is
defined without a parameter type list that ends with the ellipsis
notation, the behavior is undefined.

   On entry to the function the value of each argument expression
shall be converted to the type of its corresponding parameter, as if
by assignment to the parameter.  Array expressions and function
designators as arguments are converted to pointers before the call.  A
declaration of a parameter as ``array of type '' shall be adjusted to
``pointer to type ,'' and a declaration of a parameter as ``function
returning type '' shall be adjusted to ``pointer to function returning
type ,'' as in $3.2.2.1.  The resulting parameter type shall be an
object type.

   Each parameter has automatic storage duration.  Its identifier is
an lvalue./72/ The layout of the storage for parameters is
unspecified.

Examples

         extern int max(int a, int b)
         {
                  return a > b ? a : b;
         }

Here extern is the storage-class specifier and int is the type
specifier (each of which may be omitted as those are the defaults);
max(int a, int b) is the function declarator; and

         { return a > b ? a : b; }

is the function body.  The following similar definition uses the
identifier-list form for the parameter declarations:

         extern int max(a, b)
         int a, b;
         {
                  return a > b ? a : b;
         }

Here int a, b; is the declaration list for the parameters, which may
be omitted because those are the defaults.  The difference between
these two definitions is that the first form acts as a prototype
declaration that forces conversion of the arguments of subsequent
calls to the function, whereas the second form may not.

   To pass one function to another, one might say 

                  int f(void);
                  /*...*/
                  g(f);

Note that f must be declared explicitly in the calling function, as
its appearance in the expression g(f) was not followed by ( .  Then
the definition of g might read

         g(int (*funcp)(void))
         {
                  /*...*/ (*funcp)() /*  or funcp() ... */
         }

or, equivalently, 

         g(int func(void))
         {
                  /*...*/ func() /*  or (*func)() ... */
         }


3.7.2 External object definitions

Semantics

   If the declaration of an identifier for an object has file scope
and an initializer, the declaration is an external definition for the
identifier.

   A declaration of an identifier for an object that has file scope
without an initializer, and without a storage-class specifier or with
the storage-class specifier static , constitutes a tentative
definition.  If a translation unit contains one or more tentative
definitions for an identifier, and the translation unit contains no
external definition for that identifier, then the behavior is exactly
as if the translation unit contains a file scope declaration of that
identifier, with the composite type as of the end of the translation
unit, with an initializer equal to 0.

   If the declaration of an identifier for an object is a tentative
definition and has internal linkage, the declared type shall not be an
incomplete type.

Examples

         int i1 = 1;          /*  definition, external linkage */
         static int i2 = 2;   /*  definition, internal linkage */
         extern int i3 = 3;   /*  definition, external linkage */
         int i4;              /*  tentative definition, external linkage */
         static int i5;       /*  tentative definition, internal linkage */

         int i1;   /*  valid tentative definition, refers to previous */
         int i2;   /*  $3.1.2.2 renders undefined, linkage disagreement */
         int i3;   /*  valid tentative definition, refers to previous */
         int i4;   /*  valid tentative definition, refers to previous */
         int i5;   /*  $3.1.2.2 renders undefined, linkage disagreement */



         extern int i1; /* refers to previous, whose linkage is external */
         extern int i2; /* refers to previous, whose linkage is internal */
         extern int i3; /* refers to previous, whose linkage is external */
         extern int i4; /* refers to previous, whose linkage is external */
         extern int i5; /* refers to previous, whose linkage is internal */


